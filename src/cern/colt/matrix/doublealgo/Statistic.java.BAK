package cern.colt.matrix.algo;

import cern.colt.matrix.*;
import hep.aida.bin.DynamicBin1D;
import cern.colt.list.*;
import cern.colt.function.DoubleDoubleFunction;
/**
Basic statistics operations on matrices.
Computation of covariance, correlation, distance matrix. 
Conversion to bins with retrieval of statistical bin measures.
Also see {@link cern.jet.stat} and {@link hep.aida.bin}, in particular {@link hep.aida.bin.DynamicBin1D}.
<p>
Examples:
<table border="1" cellspacing="0" dwcopytype="CopyTableRow">
  <tr valign="top" align="center"> 
	<td><tt>A</tt></td>
	<td><tt>covariance(A)</tt></td>
	<td><tt>correlation(covariance(A))</tt></td>
	<td><tt>distance(A,EUCLID)</tt></td>
  </tr>
  <tr valign="top"> 
	<td><tt> 4&nbsp;x&nbsp;3&nbsp;matrix<br>
	  1&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3<br>
	  2&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;6<br>
	  3&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;9<br>
	  4&nbsp;-8&nbsp;-10 </tt> </td>
	<td><tt> 3&nbsp;x&nbsp;3&nbsp;matrix<br>
	  &nbsp;1.25&nbsp;-3.5&nbsp;-4.5<br>
	  -3.5&nbsp;&nbsp;29&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;<br>
	  -4.5&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;52.5 </tt></td>
	<td><tt> 3&nbsp;x&nbsp;3&nbsp;matrix<br>
	  &nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-0.581318&nbsp;-0.555492<br>
	  -0.581318&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.999507<br>
	  -0.555492&nbsp;&nbsp;0.999507&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	  </tt></td>
	<td><tt> 3&nbsp;x&nbsp;3&nbsp;matrix<br>
	  &nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12.569805&nbsp;15.874508<br>
	  12.569805&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4.242641<br>
	  15.874508&nbsp;&nbsp;4.242641&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	  </tt> <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </tt></td>
  </tr>
</table>
<p>
<b>Performance:</b>
<p>
PentiumPro 200 Mhz, NT, SunJDK 1.2.2, java -classic.<br>
Computing covariance or correlation matrix for an <tt>m x n</tt> matrix.
<ul>
<li>m = 100000, n = 10 --> 2.6 secs --> 3.8 Mflops
<li>m = 5000, n = 100 --> 10.2 secs --> 4.9 Mflops
</ul>

@author wolfgang.hoschek@cern.ch
@version 1.0, 09/24/99
*/
public class Statistic extends Object {
	/**
	 * Euclidean distance function; <tt>Sqrt(Sum( (x[i]-y[i])^2 ))</tt>.
	 */ 
	public static final int EUCLID = 0;

	/**
	 * Manhattan distance function; <tt>Sum( abs(x[i]-y[i]) )</tt>.
	 */ 
	public static final int MANHATTAN = 1;

	/**
	 * Bray-Curtis distance function; <tt>Sum( abs(x[i]-y[i]) )  /  Sum( x[i]+y[i] )</tt>.
	 */ 
	public static final int BRAY_CURTIS = 2;

	/**
	 * Canberra distance function; <tt>Sum( abs(x[i]-y[i]) / abs(x[i]+y[i]) )</tt>.
	 */ 
	public static final int CANBERRA = 3;

	/**
	 * Maximum distance function; <tt>Max( abs(x[i]-y[i]) )</tt>.
	 */ 
	public static final int MAXIMUM = 4;

/**
 * Makes this class non instantiable, but still let's others inherit from it.
 */
protected Statistic() {}
/**
Fills all cell values of the given vector into a bin from which statistics measures can be retrieved efficiently.
Cells values are copied.
<br>
Tip: Use <tt>System.out.println(bin(vector))</tt> to print most measures computed by the bin. Example:
<pre>
Size: 20000
Sum: 299858.02350278624
SumOfSquares: 5399184.154095971
Min: 0.8639113139711261
Max: 59.75331890541892
Mean: 14.992901175139313
RMS: 16.43043540825375
Variance: 45.17438077634358
Standard deviation: 6.721188940681818
Standard error: 0.04752598277592142
Geometric mean: 13.516615397064466
Product: Infinity
Harmonic mean: 11.995174297952191
Sum of inversions: 1667.337172700724
Skew: 0.8922838940067878
Kurtosis: 1.1915828121825598
Sum of powers(3): 1.1345828465808412E8
Sum of powers(4): 2.7251055344494686E9
Sum of powers(5): 7.367125643433887E10
Sum of powers(6): 2.215370909100143E12
Moment(0,0): 1.0
Moment(1,0): 14.992901175139313
Moment(2,0): 269.95920770479853
Moment(3,0): 5672.914232904206
Moment(4,0): 136255.27672247344
Moment(5,0): 3683562.8217169433
Moment(6,0): 1.1076854545500715E8
Moment(0,mean()): 1.0
Moment(1,mean()): -2.0806734113421045E-14
Moment(2,mean()): 45.172122057305664
Moment(3,mean()): 270.92018671421
Moment(4,mean()): 8553.8664869067
Moment(5,mean()): 153357.41712233616
Moment(6,mean()): 4273757.570142922
25%, 50% and 75% Quantiles: 10.030074811938091, 13.977982089912224,
18.86124362967137
quantileInverse(mean): 0.559163335012079
Distinct elements & frequencies not printed (too many).
</pre>

@param vector the vector to analyze.
@return a bin holding the statistics measures of the vector.
*/
public static DynamicBin1D bin(DoubleMatrix1D vector) {
	DynamicBin1D bin = new DynamicBin1D();
	bin.addAllOf(DoubleFactory1D.dense.toList(vector));
	return bin;
}
/**
 * Modifies the given covariance matrix to be a correlation matrix (in-place).
 * The correlation matrix is a square, symmetric matrix consisting of nothing but correlation coefficients.
 * The rows and the columns represent the variables, the cells represent correlation coefficients. 
 * The diagonal cells (i.e. the correlation between a variable and itself) will equal 1, for the simple reason that the correlation coefficient of a variable with itself equals 1. 
 * The correlation of two column vectors x and y is given by <tt>corr(x,y) = cov(x,y) / (stdDev(x)*stdDev(y))</tt> (Pearson's correlation coefficient).
 * A correlation coefficient varies between -1 (for a perfect negative relationship) to +1 (for a perfect positive relationship). 
 * See the <A HREF="http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition</A>
 * and <A HREF="http://www.stat.berkeley.edu/users/stark/SticiGui/Text/gloss.htm#correlation_coef"> another def</A>.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.
 * 
 * @param covariance a covariance matrix, as, for example, returned by method {@link #covariance(DoubleMatrix2D)}.
 * @return the modified covariance, now correlation matrix (for convenience only).
 */
public static DoubleMatrix2D correlation(DoubleMatrix2D covariance) {
	for (int i=covariance.columns(); --i >= 0; ) {
		for (int j=i; --j >= 0; ) {
			double stdDev1 = Math.sqrt(covariance.getQuick(i,i));
			double stdDev2 = Math.sqrt(covariance.getQuick(j,j));
			double cov = covariance.getQuick(i,j);
			double corr = cov / (stdDev1*stdDev2);
			
			/*
			double corr;
			if (cov == 0 && stdDev1*stdDev2==0) // 0.0 / 0.0 --> 1 (if two columns are equal and have variance=0, they are perfectly correlated)
				corr = 1;
			else 
				corr = cov / (stdDev1*stdDev2);
			*/
				
			covariance.setQuick(i,j,corr);
			covariance.setQuick(j,i,corr); // symmetric
		}
	}
	for (int i=covariance.columns(); --i >= 0; ) covariance.setQuick(i,i,1);

	return covariance;	
}
/**
 * Constructs and returns the covariance matrix of the given matrix.
 * The covariance matrix is a square, symmetric matrix consisting of nothing but covariance coefficients. 
 * The rows and the columns represent the variables, the cells represent covariance coefficients. 
 * The diagonal cells (i.e. the covariance between a variable and itself) will equal the variances.
 * The covariance of two column vectors x and y is given by <tt>cov(x,y) = (1/n) * Sum((x[i]-mean(x)) * (y[i]-mean(y)))</tt>.
 * See the <A HREF="http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition</A>.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.
 * 
 * @param matrix any matrix; a column holds the values of a given variable.
 * @return the covariance matrix (<tt>n x n, n=matrix.columns</tt>).
 */
public static DoubleMatrix2D covariance(DoubleMatrix2D matrix) {
	int rows = matrix.rows();
	int columns = matrix.columns();
	DoubleMatrix2D covariance = matrix.like(columns,columns);
	
	double[] sums = new double[columns];
	DoubleMatrix1D[] cols = new DoubleMatrix1D[columns];
	for (int i=columns; --i >= 0; ) {
		cols[i] = matrix.viewColumn(i);
		sums[i] = cols[i].zSum();
	}

	for (int i=columns; --i >= 0; ) {
		for (int j=i+1; --j >= 0; ) {
			double sumOfProducts = cols[i].zDotProduct(cols[j]);
			double cov = (sumOfProducts - sums[i]*sums[j]/rows) / rows;
			covariance.setQuick(i,j,cov);
			covariance.setQuick(j,i,cov); // symmetric
		}
	}
	return covariance;	
}
/**
 * Demonstrates usage of this class.
 */
public static void demo1() {
double[][] values = {
	{ 1, 2, 3 },
	{ 2, 4, 6 },
	{ 3, 6, 9 },
	{ 4, -8, -10 }
};
DoubleFactory2D factory = DoubleFactory2D.dense;
DoubleMatrix2D A = factory.make(values);
System.out.println(A);
System.out.println(covariance(A));
System.out.println(correlation(covariance(A)));
System.out.println(distance(A,EUCLID));


//System.out.println(cern.colt.matrixpattern.Converting.toHTML(A.toString()));
//System.out.println(cern.colt.matrixpattern.Converting.toHTML(covariance(A).toString()));
//System.out.println(cern.colt.matrixpattern.Converting.toHTML(correlation(covariance(A)).toString()));
//System.out.println(cern.colt.matrixpattern.Converting.toHTML(distance(A,EUCLID).toString()));
}
/**
 * Demonstrates usage of this class.
 */
public static void demo2(int rows, int columns, boolean print) {
System.out.println("\n\ninitializing...");
DoubleFactory2D factory = DoubleFactory2D.dense;
DoubleMatrix2D A = factory.ascending(rows,columns);
//double value = 1;
//DoubleMatrix2D A = factory.make(rows,columns);
//A.assign(value);

System.out.println("benchmarking correlation...");

cern.colt.Timer timer = new cern.colt.Timer().start();
DoubleMatrix2D corr = correlation(covariance(A));
timer.stop().display();

if (print) {
	System.out.println("printing result...");
	System.out.println(corr);
}
System.out.println("done.");
}
/**
 * Demonstrates usage of this class.
 */
public static void demo3(int norm) {
double[][] values = {
	{ -0.9611052, -0.25421095 },
	{ 0.4308269, -0.69932648 },
	{ -1.2071029,  0.62030596 },
	{ 1.5345166,  0.02135884},
	{-1.1341542,  0.20388430}
};

System.out.println("\n\ninitializing...");
DoubleFactory2D factory = DoubleFactory2D.dense;
DoubleMatrix2D A = factory.make(values).viewDice();

System.out.println("\nA="+A.viewDice());
System.out.println("\ndist="+distance(A,norm).viewDice());
}
/**
 * Constructs and returns the distance matrix of the given matrix.
 * The distance matrix is a square, symmetric matrix consisting of nothing but distance coefficients. 
 * The rows and the columns represent the variables, the cells represent distance coefficients. 
 * The diagonal cells (i.e. the distance between a variable and itself) will be zero.
 * Compares two column vectors at a time. Use dice views to compare two row vectors at a time.
 * 
 * @param matrix any matrix; a column holds the values of a given variable (vector).
 * @param norm the kind of norm to be used (EUCLID, CANBERRA, ...).
 * @return the distance matrix (<tt>n x n, n=matrix.columns</tt>).
 */
public static DoubleMatrix2D distance(DoubleMatrix2D matrix, int norm) {
	int rows = matrix.rows();
	int columns = matrix.columns();
	DoubleMatrix2D distance = matrix.like(columns,columns);

	// cache views
	DoubleMatrix1D[] cols = new DoubleMatrix1D[columns];
	for (int i=columns; --i >= 0; ) {
		cols[i] = matrix.viewColumn(i);
	}

	// setup distance function
	cern.jet.math.Functions F = cern.jet.math.Functions.functions;
	DoubleDoubleFunction function = null;
	DoubleDoubleFunction function2 = null;
	if (norm==EUCLID) function = F.chain(F.square,F.minus);
	else if (norm==BRAY_CURTIS) function = F.chain(F.abs,F.minus);
	else if (norm==CANBERRA) function = new DoubleDoubleFunction() {
		public final double apply(double a, double b) {	return Math.abs(a-b) / Math.abs(a+b);}
	};
	else if (norm==MAXIMUM) function = F.chain(F.abs,F.minus);
	else if (norm==MANHATTAN) function = F.chain(F.abs,F.minus);
	else throw new IllegalArgumentException("Unknown norm");

	// work out all permutations
	for (int i=columns; --i >= 0; ) {
		for (int j=i; --j >= 0; ) {
			double d = 0;
			if (norm==EUCLID) d = Math.sqrt(cols[i].aggregate(cols[j], F.plus, function));
			else if (norm==BRAY_CURTIS) d = cols[i].aggregate(cols[j], F.plus, function) / cols[i].aggregate(cols[j], F.plus, F.plus);
			else if (norm==CANBERRA) d = cols[i].aggregate(cols[j], F.plus, function);
			else if (norm==MAXIMUM) d = cols[i].aggregate(cols[j], F.max, function);
			else if (norm==MANHATTAN) d = cols[i].aggregate(cols[j], F.plus, function);
			distance.setQuick(i,j,d);
			distance.setQuick(j,i,d); // symmetric
		}
	}
	return distance;
}
/**
 * Benchmarks covariance computation.
 */
public static void main(String[] args) {
	int rows = Integer.parseInt(args[0]);
	int columns = Integer.parseInt(args[1]);
	boolean print = args[2].equals("print");
	demo2(rows,columns,print);
}
/**
 * Returns <tt>Sum(vector[i]) / vector.size()</tt>.
 */
private static double mean(DoubleMatrix1D vector) {
	return sum(vector) / vector.size();
}
/**
 * Returns <tt>Sum(vector[i])</tt>.
 */
private static double sum(DoubleMatrix1D vector) {
	cern.jet.math.Functions F = cern.jet.math.Functions.functions;
	if (vector.size()==0) return 0;
	return vector.aggregate(F.plus,F.identity);
}
/**
 * Constructs and returns the covariance matrix of the given matrix.
 * The rows and the columns represent the variables, the cells represent covariance coefficients. 
 * The diagonal cells (i.e. the covariance between a variable and itself) will equal the variances.
 * The covariance of two column vectors x and y is given by <tt>cov(x,y) = (1/n) * Sum((x[i]-mean(x)) * (y[i]-mean(y)))</tt>.
 * See the <A HREF="http://www.cquest.utoronto.ca/geog/ggr270y/notes/not05efg.html"> math definition</A>.
 * 
 * @param matrix any matrix; a column holds the values of a given variable.
 * @return the covariance matrix (<tt>n x n, n=matrix.columns</tt>).
 */
private static DoubleMatrix2D xdistance(DoubleMatrix1D vector, cern.colt.function.DoubleDoubleFunction distance) {
	int size = vector.size();
	DoubleMatrix2D matrix = vector.like2D(size,size);
	for (int i=size; --i >= 0; ) {
		for (int j=i+1; --j >= 0; ) {
			double dist = distance.apply(vector.getQuick(i), vector.getQuick(j));
			matrix.setQuick(i,j, dist);
			matrix.setQuick(j,i, dist);
		}
	}
	return matrix;	
}
}
