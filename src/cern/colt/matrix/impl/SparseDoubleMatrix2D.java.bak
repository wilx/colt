package cern.colt.matrix.impl;

import cern.colt.matrix.*;
import cern.colt.map.AbstractIntDoubleMap;
import cern.colt.map.OpenIntDoubleHashMap;
/**
Sparse 2-d matrix holding <tt>double</tt> elements.
First see the <a href="package-summary.html">package summary</a> and javadoc <a href="package-tree.html">tree view</a> to get the broad picture.
<p>
<b>Implementation:</b>
<p>
Note that this implementation is not synchronized.
Uses a {@link cern.colt.map.OpenIntDoubleHashMap}, which is a compact and performant hashing technique.
<p>
<b>Memory requirements:</b>
<p>
Cells that
<ul>
<li>are never set to non-zero values do not use any memory.
<li>switch from zero to non-zero state do use memory.
<li>switch back from non-zero to zero state also do use memory. However, their memory is automatically reclaimed from time to time. It can also manually be reclaimed by calling {@link #trimToSize()}.
</ul>
<p>
worst case: <tt>memory [bytes] = (1/minLoadFactor) * nonZeros * 13</tt>.
<br>best  case: <tt>memory [bytes] = (1/maxLoadFactor) * nonZeros * 13</tt>.
<br>Where <tt>nonZeros = cardinality()</tt> is the number of non-zero cells.
Thus, a 1000 x 1000 matrix with minLoadFactor=0.25 and maxLoadFactor=0.5 and 1000000 non-zero cells consumes between 25 MB and 50 MB.
The same 1000 x 1000 matrix with 1000 non-zero cells consumes between 25 and 50 KB.
<p>
<b>Time complexity:</b>
<p>
This class offers <i>expected</i> time complexity <tt>O(1)</tt> (i.e. constant time) for the basic operations
<tt>get</tt>, <tt>getQuick</tt>, <tt>set</tt>, <tt>setQuick</tt> and <tt>size</tt>
assuming the hash function disperses the elements properly among the buckets.
Otherwise, pathological cases, although highly improbable, can occur, degrading performance to <tt>O(N)</tt> in the worst case.
As such this sparse class is expected to have no worse time complexity than its dense counterpart {@link DenseDoubleMatrix2D}.
However, constant factors are considerably larger.
<p>
Cells are internally addressed in row-major.
Performance sensitive applications can exploit this fact.
Setting values in a loop row-by-row is quicker than column-by-column, because fewer hash collisions occur.
Thus
<pre>
	for (int row=0; row < rows; row++) {
		for (int column=0; column < columns; column++) {
			matrix.setQuick(row,column,someValue);
		}
	}
</pre>
is quicker than
<pre>
	for (int column=0; column < columns; column++) {
		for (int row=0; row < rows; row++) {
			matrix.setQuick(row,column,someValue);
		}
	}
</pre>

@see cern.colt.map
@see cern.colt.map.OpenIntDoubleHashMap
@author wolfgang.hoschek@cern.ch
@version 1.0, 09/24/99
*/
public class SparseDoubleMatrix2D extends DoubleMatrix2D {
	/*
	 * The elements of the matrix.
	 */
	protected AbstractIntDoubleMap elements; 
/**
 * Constructs a matrix with a copy of the given values.
 * <tt>values</tt> is required to have the form <tt>values[row][column]</tt>
 * and have exactly the same number of columns in every row.
 * <p>
 * The values are copied. So subsequent changes in <tt>values</tt> are not reflected in the matrix, and vice-versa.
 *
 * @param values The values to be filled into the new matrix.
 * @throws IllegalArgumentException if <tt>for any 1 &lt;= row &lt; values.length: values[row].length != values[row-1].length</tt>.
 */
public SparseDoubleMatrix2D(double[][] values) {
	this(values.length, values.length==0 ? 0: values[0].length);
	assign(values);
}
/**
 * Constructs a matrix with a given number of rows and columns and default memory usage.
 * All entries are initially <tt>0</tt>.
 * @param rows the number of rows the matrix shall have.
 * @param columns the number of columns the matrix shall have.
 * @throws	IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.
 */
public SparseDoubleMatrix2D(int rows, int columns) {
	this(rows,columns,rows*(columns/1000),0.2,0.5);
}
/**
 * Constructs a matrix with a given number of rows and columns using memory as specified.
 * All entries are initially <tt>0</tt>.
 * For details related to memory usage see {@link cern.colt.map.OpenIntDoubleHashMap}.
 * 
 * @param rows the number of rows the matrix shall have.
 * @param columns the number of columns the matrix shall have.
 * @param initialCapacity   the initial capacity of the hash map.
 *                          If not known, set <tt>initialCapacity=0</tt> or small.     
 * @param minLoadFactor        the minimum load factor of the hash map.
 * @param maxLoadFactor        the maximum load factor of the hash map.
 * @throws	IllegalArgumentException if <tt>initialCapacity < 0 || (minLoadFactor < 0.0 || minLoadFactor >= 1.0) || (maxLoadFactor <= 0.0 || maxLoadFactor >= 1.0) || (minLoadFactor >= maxLoadFactor)</tt>.
 * @throws	IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt>.
 */
public SparseDoubleMatrix2D(int rows, int columns, int initialCapacity, double minLoadFactor, double maxLoadFactor) {
	setUp(rows,columns); 
	this.elements = new OpenIntDoubleHashMap(initialCapacity, minLoadFactor, maxLoadFactor);
}
/**
 * Constructs a view with the given parameters.
 * @param rows the number of rows the matrix shall have.
 * @param columns the number of columns the matrix shall have.
 * @param elements the cells.
 * @param rowZero the position of the first element.
 * @param columnZero the position of the first element.
 * @param rowStride the number of elements between two rows, i.e. <tt>index(i+1,j)-index(i,j)</tt>.
 * @param columnStride the number of elements between two columns, i.e. <tt>index(i,j+1)-index(i,j)</tt>.
 * @throws	IllegalArgumentException if <tt>rows<0 || columns<0 || (double)columns*rows > Integer.MAX_VALUE</tt> or flip's are illegal.
 */
protected SparseDoubleMatrix2D(int rows, int columns, AbstractIntDoubleMap elements, int rowZero, int columnZero, int rowStride, int columnStride) {
	setUp(rows,columns,rowZero,columnZero,rowStride,columnStride);
	this.elements = elements;
	this.isNoView = false;
}
/**
 * Sets all cells to the state specified by <tt>value</tt>.
 * @param    value the value to be filled into the cells.
 * @return <tt>this</tt> (for convenience only).
 */
public DoubleMatrix2D assign(double value) {
	// overriden for performance only
	if (this.isNoView && value==0) this.elements.clear();
	else super.assign(value);
	return this;
}
public DoubleMatrix2D assign(cern.colt.function.DoubleFunction function) {
	if (this.isNoView && function instanceof cern.jet.math.Mult) { // x[i] = mult*x[i]
		this.elements.assign(function);
	}
	else {
		super.assign(function);
	}
	return this;
}
public DoubleMatrix2D assign(DoubleMatrix2D source) {
	// overriden for performance only
	if (! (source instanceof SparseDoubleMatrix2D)) {
		return super.assign(source);
	}
	SparseDoubleMatrix2D other = (SparseDoubleMatrix2D) source;
	if (other==this) return this; // nothing to do
	checkShape(other);
	
	if (this.isNoView && other.isNoView) { // quickest
		this.elements.assign(other.elements);
		return this;
	}
	return super.assign(source);
}
public DoubleMatrix2D assign(final DoubleMatrix2D y, cern.colt.function.DoubleDoubleFunction function) {
	if (!this.isNoView) return super.assign(y,function);
	
	checkShape(y);

	if (function instanceof cern.jet.math.PlusMult) { // x[i] = x[i] + alpha*y[i]
		final double alpha = ((cern.jet.math.PlusMult) function).multiplicator;
		if (alpha==0) return this; // nothing to do
		y.forEachNonZero(
			new cern.colt.function.IntIntDoubleFunction() {
				public double apply(int i, int j, double value) {
					setQuick(i,j,getQuick(i,j) + alpha*value);
					return value;
				}
			}
		);
		return this;
	}

	if (function==cern.jet.math.Functions.mult) { // x[i] = x[i] * y[i]
		this.elements.forEachPair(
			new cern.colt.function.IntDoubleProcedure() {
				public boolean apply(int key, double value) {
					int i = key/columns;
					int j = key%columns;
					double r = value * y.getQuick(i,j);
					if (r!=value) elements.put(key,r);
					return true;
				}
			}
		);
	}
	
	if (function==cern.jet.math.Functions.div) { // x[i] = x[i] / y[i]
		this.elements.forEachPair(
			new cern.colt.function.IntDoubleProcedure() {
				public boolean apply(int key, double value) {
					int i = key/columns;
					int j = key%columns;
					double r = value / y.getQuick(i,j);
					if (r!=value) elements.put(key,r);
					return true;
				}
			}
		);
	}
	
	return super.assign(y,function);
}
public int cardinality() {
	if (this.isNoView) return this.elements.size();
	else return super.cardinality();
}
public void ensureCapacity(int minCapacity) {
	this.elements.ensureCapacity(minCapacity);
}
public DoubleMatrix2D forEachNonZero(final cern.colt.function.IntIntDoubleFunction function) {
	if (this.isNoView) {
		this.elements.forEachPair(
			new cern.colt.function.IntDoubleProcedure() {
				public boolean apply(int key, double value) {
					int i = key/columns;
					int j = key%columns;
					double r = function.apply(i,j,value);
					if (r!=value) elements.put(key,r);
					return true;
				}
			}
		);
	}
	else {
		super.forEachNonZero(function);
	}
	return this;
}
public double getQuick(int row, int column) {
	//if (debug) if (column<0 || column>=columns || row<0 || row>=rows) throw new IndexOutOfBoundsException("row:"+row+", column:"+column);
	//return this.elements.get(index(row,column));
	//manually inlined:
	return this.elements.get(rowZero + row*rowStride + columnZero + column*columnStride);
}
/**
 * Returns <tt>true</tt> if both matrices share common cells.
 * More formally, returns <tt>true</tt> if at least one of the following conditions is met
 * <ul>
 * <li>the receiver is a view of the other matrix
 * <li>the other matrix is a view of the receiver
 * <li><tt>this == other</tt>
 * </ul>
 */
protected boolean haveSharedCells(DoubleMatrix2D other) {
	if (other==null) return false;
	if (this==other) return true;
	if (other instanceof SelectedSparseDoubleMatrix2D) {
		SelectedSparseDoubleMatrix2D otherMatrix = (SelectedSparseDoubleMatrix2D) other;
		return this.elements==otherMatrix.elements;
	}
	else if (other instanceof SparseDoubleMatrix2D) {
		SparseDoubleMatrix2D otherMatrix = (SparseDoubleMatrix2D) other;
		return this.elements==otherMatrix.elements;
	}
	return false;
}
/**
 * Returns the position of the given coordinate within the (virtual or non-virtual) internal 1-dimensional array. 
 *
 * @param     row   the index of the row-coordinate.
 * @param     column   the index of the column-coordinate.
 */
protected int index(int row, int column) {
	// return super.index(row,column);
	// manually inlined for speed:
	return rowZero + row*rowStride + columnZero + column*columnStride;
}
public DoubleMatrix2D like(int rows, int columns) {
	return new SparseDoubleMatrix2D(rows, columns);
}
public DoubleMatrix1D like1D(int size) {
	return new SparseDoubleMatrix1D(size);
}
public void trimToSize() {}protected DoubleMatrix1D like1D(int size, int offset, int stride) {
	return new SparseDoubleMatrix1D(size,this.elements,offset,stride);
}
public void setQuick(int row, int column, double value) {
	//if (debug) if (column<0 || column>=columns || row<0 || row>=rows) throw new IndexOutOfBoundsException("row:"+row+", column:"+column);
	//int index =	index(row,column);
	//manually inlined:
	int index = rowZero + row*rowStride + columnZero + column*columnStride;

	//if (value == 0 || Math.abs(value) < TOLERANCE)
	if (value == 0)
		this.elements.removeKey(index);
	else 
		this.elements.put(index, value);
}
public void trimToSize() {
	this.elements.trimToSize();
}
/**
 * Construct and returns a new selection view.
 *
 * @param rowOffsets the offsets of the visible elements.
 * @param columnOffsets the offsets of the visible elements.
 * @return  a new view.
 */
protected DoubleMatrix2D viewSelectionLike(int[] rowOffsets, int[] columnOffsets) {
	return new SelectedSparseDoubleMatrix2D(this.elements,rowOffsets,columnOffsets,0);
}
/**
 * Returns a string representation using default formatting.
 * @see cern.colt.matrix.doublealgo.Formatter
 */
protected String xtoString() {
	final DenseDoubleMatrix2D copy = new DenseDoubleMatrix2D(rows(),columns());

	cern.colt.function.IntDoubleProcedure proc = new cern.colt.function.IntDoubleProcedure() {
		public boolean apply(int addr, double value) {
			int a = addr-rowZero-columnZero;
			int rs = Math.abs(rowStride);
			int cs = Math.abs(columnStride);
			int r = a / rowStride;
			int c = a % rowStride;
			
			if (c%cs==0) c = c/cs;
			else return true; // this cell does not belong to me
			System.out.println("step 1: addr="+addr+", r="+r+", c="+c);
			int v = rowStride*r;
			if (columnStride>0) {
				if (a-v < 0 || a-v >= columns * columnStride) return true; // this cell does not belong to me
			}
			else {
				if (a-v > 0 || a-v <= columns * columnStride) return true; // this cell does not belong to me
			}
			System.out.println("step 2: addr="+addr+", r="+r+", c="+c);
			if (r<0 || r>=rows || c<0 || c>=columns) return true; // this cell does not belong to me

			System.out.println("step 3: addr="+addr+", r="+r+", c="+c);
			// belongs to me
			copy.setQuick(r,c, value);
			
			return true;
		}
	};
	this.elements.forEachPair(proc);
	return copy.toString();
}
/**
 * Returns a string representation using default formatting.
 * @see cern.colt.matrix.doublealgo.Formatter
 */
private String xxtoString() {
	final DenseDoubleMatrix2D copy = new DenseDoubleMatrix2D(rows(),columns());

	cern.colt.function.IntDoubleProcedure proc = new cern.colt.function.IntDoubleProcedure() {
		public boolean apply(int addr, double value) {
			int a = addr-rowZero;
			int r = a / rowStride;
			int c = addr-rowZero-columnZero- r*rowStride;
			System.out.println("step 1: addr="+addr+", r="+r+", c="+c);
			if (c%columnStride != 0) return true;
			c=c/columnStride;
			
			//if (c%columnStride==0) c = c/columnStride;
			/*
			else return true; // this cell does not belong to me
			System.out.println("step 1: addr="+addr+", r="+r+", c="+c);
			int v = rowStride*r;
			if (columnStride>0) {
				if (a-v < 0 || a-v >= columns * columnStride) return true; // this cell does not belong to me
			}
			else {
				if (a-v > 0 || a-v <= columns * columnStride) return true; // this cell does not belong to me
			}
			*/
			System.out.println("step 2: addr="+addr+", r="+r+", c="+c);
			if (r<0 || r>=rows || c<0 || c>=columns) return true; // this cell does not belong to me

			System.out.println("step 3: addr="+addr+", r="+r+", c="+c);
			// belongs to me
			copy.setQuick(r,c, value);
			
			return true;
		}
	};
	this.elements.forEachPair(proc);
	return copy.toString();
}
public DoubleMatrix1D zMult(DoubleMatrix1D y, DoubleMatrix1D z, double alpha, double beta) {
	if (!(this.isNoView && y instanceof DenseDoubleMatrix1D && z instanceof DenseDoubleMatrix1D)) {
		return super.zMult(y,z,alpha,beta);
	}
	boolean ignore = (z==null);
	if (z==null) z = y.like(this.rows);
	
	if (columns != y.size() || rows > z.size())	
		throw new IllegalArgumentException("Incompatible args: "+toStringShort()+", "+y.toStringShort()+", "+z.toStringShort());

	if (!ignore) z.assign(cern.jet.math.Functions.mult(beta/alpha));
	
	DenseDoubleMatrix1D zz = (DenseDoubleMatrix1D) z;
	final double[] zElements = zz.elements;
	final int zStride = zz.stride;
	final int zi = z.index(0);
	
	DenseDoubleMatrix1D yy = (DenseDoubleMatrix1D) y;
	final double[] yElements = yy.elements;
	final int yStride = yy.stride;
	final int yi = y.index(0);

	if (yElements==null || zElements==null) throw new InternalError();

	this.elements.forEachPair(
		new cern.colt.function.IntDoubleProcedure() {
			public boolean apply(int key, double value) {
				int i = key/columns;
				int j = key%columns;
				zElements[zi + zStride*i] += value * yElements[yi + yStride*j];
				//System.out.println("["+i+","+j+"]-->"+value);
				return true;
			}
		}
	);
	
	/*
	forEachNonZero(
		new cern.colt.function.IntIntDoubleFunction() {
			public double apply(int i, int j, double value) {
				zElements[zi + zStride*i] += value * yElements[yi + yStride*j];
				//z.setQuick(row,z.getQuick(row) + value * y.getQuick(column));
				//System.out.println("["+i+","+j+"]-->"+value);
				return value;
			}
		}
	);
	*/
	
	if (alpha!=1) z.assign(cern.jet.math.Functions.mult(alpha));
	return z;
}
public DoubleMatrix2D zMult(DoubleMatrix2D B, DoubleMatrix2D C, final double alpha, double beta) {
	if (!(this.isNoView)) {
		return super.zMult(B,C,alpha,beta);
	}
	int m = rows;
	int n = columns;
	int p = B.columns;
	boolean ignore = (C==null);
	if (C==null) C = B.like(m,p);

	if (B.rows != n)
		throw new IllegalArgumentException("Matrix2D inner dimensions must agree:"+toStringShort()+", "+B.toStringShort());
	if (C.rows != m || C.columns != p)
		throw new IllegalArgumentException("Incompatibel result matrix: "+toStringShort()+", "+B.toStringShort()+", "+C.toStringShort());
	if (this == C || B == C)
		throw new IllegalArgumentException("Matrices must not be identical");
	
	if (!ignore) C.assign(cern.jet.math.Functions.mult(beta));

	// cache views	
	final DoubleMatrix1D[] Brows = new DoubleMatrix1D[n];
	for (int i=n; --i>=0; ) Brows[i] = B.viewRow(i);
	final DoubleMatrix1D[] Crows = new DoubleMatrix1D[m];
	for (int i=m; --i>=0; ) Crows[i] = C.viewRow(i);

	final cern.jet.math.PlusMult fun = cern.jet.math.PlusMult.plusMult(0);

	this.elements.forEachPair(
		new cern.colt.function.IntDoubleProcedure() {
			public boolean apply(int key, double value) {
				int i = key/columns;
				int j = key%columns;
				fun.multiplicator = value*alpha;
				Crows[i].assign(Brows[j],fun);
				return true;
			}
		}
	);

	return C;
}
}
