<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Mon May 15 23:45:11 CEST 2000 -->
<TITLE>
Colt 1.0.1 - API Specification: Class  PooledExecutor
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/PooledExecutor.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Colt 1.0.1</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/ObservableSync.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PrioritySemaphore.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PooledExecutor.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
edu.oswego.cs.dl.util.concurrent</FONT>
<BR>
Class  PooledExecutor</H2>
<PRE>
<A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html">java.lang.Object</A>
  |
  +--<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/ThreadFactoryUser.html">edu.oswego.cs.dl.util.concurrent.ThreadFactoryUser</A>
        |
        +--<B>edu.oswego.cs.dl.util.concurrent.PooledExecutor</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Executor.html">Executor</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>PooledExecutor</B><DT>extends <A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/ThreadFactoryUser.html">ThreadFactoryUser</A><DT>implements <A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Executor.html">Executor</A></DL>

<P>
A tunable, extensible thread pool class. The main supported public
 method is <code>execute(Runnable command)</code>, which
 can be called instead of directly creating threads
 to execute commands.
 <p>
 Thread pools can be useful for several, usually intertwined
 reasons:
 <ul>
    <li> To bound resource use. A limit can be
          placed on the maximum number of simultaneously executing
          threads.
    <li> To manage concurrency levels. A targeted number of
          threads can be allowed to execute simultaneously.
    <li> To manage a set of threads performing related tasks.
    <li> To minimize overhead, by reusing previously constructed
          Thread objects rather than creating new ones.
          (Note however that pools are hardly ever cure-alls 
          for performance problems associated with thread construction,
          especially on JVMs that themselves internally pool or
          recycle threads.)
 </ul>
 These goals introduce a number of policy parameters
 that are encapsulated in this class. All of these parameters
 have defaults and are tunable,
 either via get/set methods, or, in cases where decisions
 should hold across lifetimes, via methods that can be easily
 overridden in subclasses.  The main, most
 commonly set parameters can be established in constructors.
 Policy choices across these dimensions can and do interact.
 Be careful. See the usage examples below.

 <dl>
   <dt> Queueing 
   <dd> By default, this pool uses queueless synchronous channels to
        to hand off work to threads. This is a safe, conservative
        policy that avoids lockups
        when handling sets of requests that might have
        internal dependencies. (In these cases, queuing one task
        could lock up another that
        would be able to continue if the queued task were to run.) 
        If you are sure that this cannot happen, then you can
        instead supply a queue of some sort (for example,
        a BoundedBuffer or LinkedQueue) in the constructor.
        This will cause new commands to be queued in cases where
        all MaximumPoolSize threads are busy. Queues are sometimes
        appropriate when each task is completely independent of
        others, so tasks cannot affect each others execution. 
        For example, in an http server.
        <p>
        When given a choice, this pool always prefers adding
        a new thread rather than queueing if there are currently 
        fewer than the
        current getMinimumPoolSize threads running, 
        but otherwise always prefers queuing
        a request rather than adding a new thread. Thus, if you use an
        unbounded buffer, you will never have more than
        getMinimumPoolSize threads running. (Since the
        default minimumPoolSize is one, you will probably want to
        explicitly setMinimumPoolSize.)
        <p>
         While queuing can be useful in smoothing out transient
         bursts of requests, especially in socket-based services, 
         it is not very well behaved 
         when commands continue to arrive
         on average faster than they can be processed. 
         Using bounds for both the queue and the 
         pool size, along with run-when-blocked policy
         is often a reasonable response to such possibilities.
         <p>
         Queue sizes and maximum pool sizes can often be traded
         off for each other. Using large queues and small pools
         minimizes CPU usage, OS resources, and context-switching overhead,
         but can lead to artifically low
         throughput. Especially if tasks frequently block (for example if
         they are I/O bound),  a JVM and underlying OS may be able
         to schedule time for more threads than you otherwise
         allow. Use of small queues or queueless handoffs generally
         requires larger pool sizes, which keeps CPUs busier
         but may encounter unacceptable scheduling overhead,
         which also decreases throughput.
         <p>
   <dt> Maximum Pool size
   <dd> The maximum number of threads to use, when needed. 
        The pool does not by default preallocate threads. 
        Instead, a thread is created, if
        necessary and if there are fewer than the maximum, only
        when an <code>execute</code> request arrives.
        The default value is (for all practical purposes) infinite --
        <code>Integer.MAX_VALUE</code>, so should
        be set in the constructor or the set method unless you
        are just using the pool to minimize construction overhead.
        Because task handoffs to idle worker threads require synchronization
        that in turn relies on JVM scheduling policies to ensure progress,
        it is possible that a new thread will be created even though
        an existing worker thread has just become idle but has not progressed
        to the point at which it can accept a new task. This phenomenon
        tends to occur on some JVMs when bursts of short tasks
        are executed.
        <p>
   <dt> Minimum Pool size
   <dd> The minimum number of threads to use, when needed (default 1).
        When a new request is received, and fewer than the
        minimum number of threads are running, a new thread is
        always created to handle the request even if other
        worker threads are idly waiting for work. Otherwise,
        a new thread is created only if there are fewer than the
        maximum and the request cannot immediately be queued.
        <p>
   <dt> Preallocation
   <dd> You can override lazy thread construction
        policies via method createThreads, which establishes
        a given number of warm threads. Be aware that these preallocated
        threads will time out and die (and later be replaced
        with others if needed) if not used within the
        keep-alive time window. If you use preallocation, you
        probably want to increase the keepalive time.
        The difference between setMinimumPoolSize and createThreads
        is that createThreads immediately establishes threads,
        while setting the minimum pool size waits until requests
        arrive. 
        <p>
   <dt> Keep-alive time
   <dd> If the pool maintained references to a fixed set of
        threads in the pool,
        then it would impede garbage collection of otherwise
        idle threads. This would defeat the resource-management
        aspects of pools. One solution would be to use weak references.
        However, this would impose costly and difficult 
        synchronization issues.
        Instead, threads are simply allowed to terminate
        and thus be GCable if they have been idle for the 
        given keep-alive time.  The value of this parameter
        represents a trade-off between GCability and construction
        time. In most current Java VMs, thread 
        construction and cleanup overhead
        is on the order of milliseconds. The
        default keep-alive value is one minute, which means that
        the time needed to construct and then GC a thread is expended
        at most once per minute.
        <p>
        To establish worker threads permanently, use a <em>negative</em>
        argument to setKeepAliveTime.
        <p>
   <dt> Blocked execution policy
   <dd> If the maximum pool size or queue size is
        bounded, then it is possible for incoming <code>execute</code>
        requests to block. There are three supported policies
        for handling this problem, and mechanics (based on
        the Strategy Object pattern) to allow
        others in subclasses: <p>
       <dl>
         <dt> Run (the default)
         <dd> The thread making the <code>execute</code> request
              runs the task itself.
              This policy helps guard against lockup. 
         <dt> Wait
         <dd> Wait until a thread becomes available.
         <dt> Discard 
         <dd> Throw away the current request and return.
       </dl>
        Other plausible policies include raising the maximum pool
        size after checking with some other objects that this is OK.
        <p>
        (Again, these cases can never occur if 
        the maximum pool size is unbounded or the queue is unbounded.
        In these cases you instead face potential resource exhaustion.)
        The execute method does not throw any checked exceptions
        in any of these cases since any errors associated with them
        must normally be dealt with via handlers or callbacks. (Although
        in some cases, these might be associated with throwing
        unchecked exceptions.)
        You may wish to add special implementations
        even if you choose one of the listed policies. For example,
        the supplied Discard policy does not inform the caller of
        the drop. You could add your own version that does so.
        Since choice of policies is normally a system-wide decision,
        selecting a policy affects all calls to <code>execute</code>.
        If for some reason you would instead like to make per-call decisions,
        you could add variant versions of the <code>execute</code>
        method (for example, <code>executeIfWouldNotBlock</code>) in
        subclasses. 
        <p>
   <dt> Thread construction parameters
   <dd> 
        A settable ThreadFactory establishes each new thread.
        By default, it merely generates a new instance of
        class Thread, but can be changed to use a
        Thread subclass, to set priorities, ThreadLocals, etc.
        <p>
   <dt> Interruption policy
   <dd>  Worker threads check for interruption after  processing
      each command, and terminate upon interruption. 
      Fresh threads will replace
      them if needed. Thus, new tasks will not start
      out in an interrupted state due to an uncleared interruption in a
      previous task. Also, unprocessed commands are never dropped
      upon interruption. It would conceptually suffice simply to clear
      interruption between tasks, but implementation characteristics
      of interruption-based methods are uncertain enough to warrant
      this conservative strategy. It is a good idea to be 
      equally conservative
      in your code for the tasks running within pools. Normally, before
      shutting down a pool via method interruptAll, you should make
      sure that all clients of the pool are themselves terminated,
      in order to prevent hanging or lost commands. Additionally,
      if you are using some form of queuing, you may wish to
      call method drain() to remove (and return)
      unprocessed commands from
      the queue after shutting down
      the pool and its clients. If you need to be sure these
      commands are processed, you can then run() each of the
      commands in the list returned by drain().

 </dl>
 <p>
 <b>Usage examples.</b>
 <p>
 Probably the most common use of pools is in statics or singletons accessible
 from a number of classes in a package;
 for example:
 <pre>
 class MyPool {
   // initialize to use a maximum of 8 threads.
   static PooledExecutor pool = new PooledExecutor(8);
 }
 </pre>
 Here are some sample variants in initialization:
 <ol>
  <li> Using a bounded buffer of 10 tasks, at least 4 threads (started only
       when needed due to incoming requests), but allowing
       up to 100 threads if the buffer gets full.
     <pre>
        pool = new PooledExecutor(new BoundedBuffer(10), 100);
        pool.setMinimumPoolSize(4);
     </pre>
  <li> Same as (1), except pre-start 9 threads, allowing them to
        die if they are not used for five minutes.
     <pre>
        pool = new PooledExecutor(new BoundedBuffer(10), 100);
        pool.setMinimumPoolSize(4);
        pool.setKeepAliveTime(1000 * 60 * 5);
        pool.createThreads(9);
     </pre>
  <li> Same as (2) except clients block if both the buffer is full and
       all 100 threads are busy:
     <pre>
        pool = new PooledExecutor(new BoundedBuffer(10), 100);
        pool.setMinimumPoolSize(4);
        pool.setKeepAliveTime(1000 * 60 * 5);
        pool.waitWhenBlocked();
        pool.createThreads(9);
     </pre>
  <li> An unbounded queue serviced by exactly 5 threads:
     <pre>
        pool = new PooledExecutor(new LinkedQueue());
        pool.setKeepAliveTime(-1); // live forever
        pool.createThreads(5);
     </pre>
  </ol>

 <p>
 <b>Usage notes.</b>
 <p>
 Pools do not mesh well with using thread-specific storage via
 java.lang.ThreadLocal.  ThreadLocal relies on the identity of a
 thread executing a particular task. Pools use the same thread to 
 perform different tasks.
 <p>
 If you need a policy not handled by the parameters in this class
 consider writing a subclass.
 <p>
 Version note: Previous versions of this class relied on ThreadGroups
 for aggregate control. This has been removed, and the method
 interruptAll added, to avoid differences in behavior across JVMs.

 <p>[<a href="http://gee.cs.oswego.edu/dl/classes/EDU/oswego/cs/dl/util/concurrent/intro.html"> Introduction to this package. </a>]
<P>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#DEFAULT_KEEPALIVETIME">DEFAULT_KEEPALIVETIME</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum time to keep worker threads alive waiting for new
 tasks; used if not otherwise specified.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#DEFAULT_MAXIMUMPOOLSIZE">DEFAULT_MAXIMUMPOOLSIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum pool size; used if not otherwise specified.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#DEFAULT_MINIMUMPOOLSIZE">DEFAULT_MINIMUMPOOLSIZE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The minimum pool size; used if not otherwise specified.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#PooledExecutor()">PooledExecutor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new pool with all default settings</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#PooledExecutor(edu.oswego.cs.dl.util.concurrent.Channel)">PooledExecutor</A></B>(<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Channel.html">Channel</A>&nbsp;channel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new pool that uses the supplied Channel for queuing,
 and with all default parameter settings.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#PooledExecutor(edu.oswego.cs.dl.util.concurrent.Channel, int)">PooledExecutor</A></B>(<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Channel.html">Channel</A>&nbsp;channel,
               int&nbsp;maxPoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new pool that uses the supplied Channel for queuing,
 and with all default parameter settings  except
 for maximum pool size.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#PooledExecutor(int)">PooledExecutor</A></B>(int&nbsp;maxPoolSize)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create a new pool with all default settings except
 for maximum pool size.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#createThreads(int)">createThreads</A></B>(int&nbsp;numberOfThreads)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create and start up to numberOfThreads threads in the pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#discardWhenBlocked()">discardWhenBlocked</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the policy for blocked execution to be to
 return without executing the request</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/util/List.html">List</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#drain()">drain</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Remove all unprocessed tasks from pool queue, and
 return them in a java.util.List.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#execute(java.lang.Runnable)">execute</A></B>(<A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Runnable.html">Runnable</A>&nbsp;command)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Arrange for the given command to be executed by a thread in this pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#getKeepAliveTime()">getKeepAliveTime</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the number of milliseconds to keep threads
 alive waiting for new commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#getMaximumPoolSize()">getMaximumPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the maximum number of threads to simultaneously execute
 New requests will be handled according to the current
 blocking policy once this limit is exceeded.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#getMinimumPoolSize()">getMinimumPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the minimum number of threads to simultaneously execute.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#getPoolSize()">getPoolSize</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the current number of active threads in the pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#interruptAll()">interruptAll</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Interrupt all threads in the pool, causing them all
 to terminate.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#runWhenBlocked()">runWhenBlocked</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the policy for blocked execution to be that
 the current thread executes the command if
 there are no available threads in the pool.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#setKeepAliveTime(long)">setKeepAliveTime</A></B>(long&nbsp;msecs)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the number of milliseconds to keep threads
 alive waiting for new commands.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#setMaximumPoolSize(int)">setMaximumPoolSize</A></B>(int&nbsp;newMaximum)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the maximum number of threads to use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#setMinimumPoolSize(int)">setMinimumPoolSize</A></B>(int&nbsp;newMinimum)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the minimum number of threads to use.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PooledExecutor.html#waitWhenBlocked()">waitWhenBlocked</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the policy for blocked execution to be to
 wait until a thread is available.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_edu.oswego.cs.dl.util.concurrent.ThreadFactoryUser"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class edu.oswego.cs.dl.util.concurrent.<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/ThreadFactoryUser.html">ThreadFactoryUser</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/ThreadFactoryUser.html#getThreadFactory()">getThreadFactory</A>, <A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/ThreadFactoryUser.html#setThreadFactory(edu.oswego.cs.dl.util.concurrent.ThreadFactory)">setThreadFactory</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#getClass()">getClass</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#notify()">notify</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#toString()">toString</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#wait()">wait</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#wait(long)">wait</A>, <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="DEFAULT_MAXIMUMPOOLSIZE"><!-- --></A><H3>
DEFAULT_MAXIMUMPOOLSIZE</H3>
<PRE>
public static final int <B>DEFAULT_MAXIMUMPOOLSIZE</B></PRE>
<DL>
<DD>The maximum pool size; used if not otherwise specified.
 Default value is essentially infinite (Integer.MAX_VALUE)</DL>
<HR>

<A NAME="DEFAULT_MINIMUMPOOLSIZE"><!-- --></A><H3>
DEFAULT_MINIMUMPOOLSIZE</H3>
<PRE>
public static final int <B>DEFAULT_MINIMUMPOOLSIZE</B></PRE>
<DL>
<DD>The minimum pool size; used if not otherwise specified.
 Default value is 1.</DL>
<HR>

<A NAME="DEFAULT_KEEPALIVETIME"><!-- --></A><H3>
DEFAULT_KEEPALIVETIME</H3>
<PRE>
public static final long <B>DEFAULT_KEEPALIVETIME</B></PRE>
<DL>
<DD>The maximum time to keep worker threads alive waiting for new
 tasks; used if not otherwise specified. Default
 value is one minute (60000 milliseconds).</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="PooledExecutor()"><!-- --></A><H3>
PooledExecutor</H3>
<PRE>
public <B>PooledExecutor</B>()</PRE>
<DL>
<DD>Create a new pool with all default settings</DL>
<HR>

<A NAME="PooledExecutor(int)"><!-- --></A><H3>
PooledExecutor</H3>
<PRE>
public <B>PooledExecutor</B>(int&nbsp;maxPoolSize)</PRE>
<DL>
<DD>Create a new pool with all default settings except
 for maximum pool size.</DL>
<HR>

<A NAME="PooledExecutor(edu.oswego.cs.dl.util.concurrent.Channel)"><!-- --></A><H3>
PooledExecutor</H3>
<PRE>
public <B>PooledExecutor</B>(<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Channel.html">Channel</A>&nbsp;channel)</PRE>
<DL>
<DD>Create a new pool that uses the supplied Channel for queuing,
 and with all default parameter settings.</DL>
<HR>

<A NAME="PooledExecutor(edu.oswego.cs.dl.util.concurrent.Channel, int)"><!-- --></A><H3>
PooledExecutor</H3>
<PRE>
public <B>PooledExecutor</B>(<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Channel.html">Channel</A>&nbsp;channel,
                      int&nbsp;maxPoolSize)</PRE>
<DL>
<DD>Create a new pool that uses the supplied Channel for queuing,
 and with all default parameter settings  except
 for maximum pool size.</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="createThreads(int)"><!-- --></A><H3>
createThreads</H3>
<PRE>
public int <B>createThreads</B>(int&nbsp;numberOfThreads)</PRE>
<DL>
<DD>Create and start up to numberOfThreads threads in the pool.
 Return the number created. This may be less than the
 number requested if creating more would exceed maximum
 pool size bound.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="discardWhenBlocked()"><!-- --></A><H3>
discardWhenBlocked</H3>
<PRE>
public void <B>discardWhenBlocked</B>()</PRE>
<DL>
<DD>Set the policy for blocked execution to be to
 return without executing the request<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="drain()"><!-- --></A><H3>
drain</H3>
<PRE>
public <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/util/List.html">List</A> <B>drain</B>()</PRE>
<DL>
<DD>Remove all unprocessed tasks from pool queue, and
 return them in a java.util.List. It should normally be used only
 when there are not any active clients of the pool (otherwise
 you face the possibility that the method will loop
 pulling out tasks as clients are putting them in.)
 This method can be useful after
 shutting down a pool (via interruptAll) to determine
 whether there are any pending tasks that were not processed.
 You can then, for example execute all unprocessed commands
 via code along the lines of:
 <pre>
   List tasks = pool.drain();
   for (Iterator it = tasks.iterator(); it.hasNext();) 
     ( (Runnable)(it.next()) ).run();
 </pre><DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="execute(java.lang.Runnable)"><!-- --></A><H3>
execute</H3>
<PRE>
public void <B>execute</B>(<A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/Runnable.html">Runnable</A>&nbsp;command)
             throws <A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/InterruptedException.html">InterruptedException</A></PRE>
<DL>
<DD>Arrange for the given command to be executed by a thread in this pool.
 The method normally returns when the command has been handed off
 for (possibly later) execution.<DD><DL>
<DT><B>Specified by: </B><DD><CODE><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Executor.html#execute(java.lang.Runnable)">execute</A></CODE> in interface <CODE><A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/Executor.html">Executor</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getKeepAliveTime()"><!-- --></A><H3>
getKeepAliveTime</H3>
<PRE>
public long <B>getKeepAliveTime</B>()</PRE>
<DL>
<DD>Return the number of milliseconds to keep threads
 alive waiting for new commands. A negative value
 means to wait forever. A zero value means not to wait
 at all.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMaximumPoolSize()"><!-- --></A><H3>
getMaximumPoolSize</H3>
<PRE>
public int <B>getMaximumPoolSize</B>()</PRE>
<DL>
<DD>Return the maximum number of threads to simultaneously execute
 New requests will be handled according to the current
 blocking policy once this limit is exceeded.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getMinimumPoolSize()"><!-- --></A><H3>
getMinimumPoolSize</H3>
<PRE>
public int <B>getMinimumPoolSize</B>()</PRE>
<DL>
<DD>Return the minimum number of threads to simultaneously execute.
 (Default value is 1).
 If fewer than the mininum number are running upon reception
 of a new request, a new thread is started to handle this request.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getPoolSize()"><!-- --></A><H3>
getPoolSize</H3>
<PRE>
public int <B>getPoolSize</B>()</PRE>
<DL>
<DD>Return the current number of active threads in the pool.
 This number is just a snaphot, and may change immediately
 upon returning<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="interruptAll()"><!-- --></A><H3>
interruptAll</H3>
<PRE>
public void <B>interruptAll</B>()</PRE>
<DL>
<DD>Interrupt all threads in the pool, causing them all
 to terminate. Assuming that executed tasks do not
 disable (clear) interruptions, each thread will terminate after
 processing its current task. Threads will terminate
 sooner if the executed tasks themselves respond to
 interrupts.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="runWhenBlocked()"><!-- --></A><H3>
runWhenBlocked</H3>
<PRE>
public void <B>runWhenBlocked</B>()</PRE>
<DL>
<DD>Set the policy for blocked execution to be that
 the current thread executes the command if
 there are no available threads in the pool.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setKeepAliveTime(long)"><!-- --></A><H3>
setKeepAliveTime</H3>
<PRE>
public void <B>setKeepAliveTime</B>(long&nbsp;msecs)</PRE>
<DL>
<DD>Set the number of milliseconds to keep threads
 alive waiting for new commands. A negative value
 means to wait forever. A zero value means not to wait
 at all.<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setMaximumPoolSize(int)"><!-- --></A><H3>
setMaximumPoolSize</H3>
<PRE>
public void <B>setMaximumPoolSize</B>(int&nbsp;newMaximum)</PRE>
<DL>
<DD>Set the maximum number of threads to use. Decreasing
 the pool size will not immediately  kill existing threads,
 but they may later die when idle.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if less or equal to zero.
 (It is
 not considered an error to set the maximum to be less than than
 the minimum. However, in this case there are no guarantees
 about behavior.)</DL>
</DD>
</DL>
<HR>

<A NAME="setMinimumPoolSize(int)"><!-- --></A><H3>
setMinimumPoolSize</H3>
<PRE>
public void <B>setMinimumPoolSize</B>(int&nbsp;newMinimum)</PRE>
<DL>
<DD>Set the minimum number of threads to use.<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/products/jdk/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if less than zero. (It is
 not considered an error to set the minimum to be greater than
 the maximum. However, in this case there are no guarantees
 about behavior.)</DL>
</DD>
</DL>
<HR>

<A NAME="waitWhenBlocked()"><!-- --></A><H3>
waitWhenBlocked</H3>
<PRE>
public void <B>waitWhenBlocked</B>()</PRE>
<DL>
<DD>Set the policy for blocked execution to be to
 wait until a thread is available.<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/PooledExecutor.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Colt 1.0.1</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/ObservableSync.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../../edu/oswego/cs/dl/util/concurrent/PrioritySemaphore.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="PooledExecutor.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<font size="-1"><a href="mailto:wolfgang.hoschek@cern.ch">Submit a bug or feature</a>. Check the <a href="http://nicewww.cern.ch/~hoschek/colt/index.htm">Colt home page</a> for the latest news.</font>
</BODY>
</HTML>
