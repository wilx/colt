<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Thu Nov 28 11:33:46 CET 2002 -->
<TITLE>
Colt 1.0.3 - API Specification: Class  Sorting
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Sorting.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Colt 1.0.3</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jal/SHORT/Range.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sorting.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
jal.SHORT</FONT>
<BR>
Class  Sorting</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html">java.lang.Object</A>
  |
  +--<B>jal.SHORT.Sorting</B>
</PRE>
<HR>
<DL>
<DT>public final class <B>Sorting</B><DT>extends <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html">Object</A></DL>

<P>
A class that encapsulates sorting and related algorithms on one
 and two arrays.  All methods are static and all variables are
 static and final, so this class has no constructors.

<P>
 Most methods operate on a range of elements.  A range is described
 by the index of its first element and an index that is 
 <strong>one past</strong> its last element.  So, for example,
 <code>[n, n+1)</code> is a range that contains one element,
 <code>[n, n)</code> is a range that contains zero elements,
 and <code>[n, n-1)</code> is not a valid range.

 <P>
 Many methods require a <em>comparison function</em>, an object of class
 BinaryPredicate.  If <code>comp</code> is a comparison function, then
 <code>comp.apply(a,b)</code> should return <code>true</code> if 
 <code>a</code> is less than <code>b</code>, and <code>false</code>
 if <code>a</code> is greater than or equal to <code>b</code>.  In 
 particular, <code>comp</code> must satisfy the requirement that, 
 for any element <code>a</code>, <code>comp.apply(a,a)</code> is
 <code>false</code>.

 <P>
 Note that an inequality operator defines an equivalence relation:
 two elements <code>a</code> and <code>b</code> are equivalent if
 and only if the relations <code>comp.apply(a,b)</code> and
 <code>comp.apply(b,a)</code> are both <code>false</code>.  Unless
 explicitly stated otherwise, the algorithms in this class always
 use this equivalence relation rather than the <code>==</code> 
 operator or <code>Object.equals()</code>.

 <P>Copyright &copy; 1996
 Silicon Graphics, Inc.

 <BR>Permission to use, copy, modify, distribute and sell this software
 and its documentation for any purpose is hereby granted without fee,
 provided that the above copyright notice appear in all copies and
 that both that copyright notice and this permission notice appear
 in supporting documentation.  Silicon Graphics makes no
 representations about the suitability of this software for any
 purpose.  It is provided &quot;as is&quot; without express or 
 implied warranty.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Inspection.html"><CODE>Inspection</CODE></A>, 
<A HREF="../../jal/SHORT/Modification.html"><CODE>Modification</CODE></A>, 
<A HREF="../../jal/SHORT/Numeric.html"><CODE>Numeric</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short)">binary_search</A></B>(short[]&nbsp;array,
              int&nbsp;first,
              int&nbsp;last,
              short&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range:
 determines whether the range contains an element equivalent to a
 certain value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short, jal.SHORT.BinaryPredicate)">binary_search</A></B>(short[]&nbsp;array,
              int&nbsp;first,
              int&nbsp;last,
              short&nbsp;x,
              <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range:
 determines whether the range contains an element equivalent to a
 certain value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../jal/SHORT/Range.html">Range</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short)">equal_range</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            short&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range:
 Finds the largest subrange in the supplied range such that an
 element can be inserted at any point in that subrange without violating
 the existing ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../jal/SHORT/Range.html">Range</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short, jal.SHORT.BinaryPredicate)">equal_range</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            short&nbsp;x,
            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range:
 Finds the largest subrange in the supplied range such that an
 element can be inserted at any point in that subrange without violating
 the existing ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)">includes</A></B>(short[]&nbsp;array1,
         short[]&nbsp;array2,
         int&nbsp;first1,
         int&nbsp;last1,
         int&nbsp;first2,
         int&nbsp;last2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether the first range is a superset of the second; both ranges
 must be sorted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int, jal.SHORT.BinaryPredicate)">includes</A></B>(short[]&nbsp;array1,
         short[]&nbsp;array2,
         int&nbsp;first1,
         int&nbsp;last1,
         int&nbsp;first2,
         int&nbsp;last2,
         <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tests whether the first range is a superset of the second; both ranges
 must be sorted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#inplace_merge(short[], int, int, int)">inplace_merge</A></B>(short[]&nbsp;array,
              int&nbsp;first,
              int&nbsp;middle,
              int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms two consecutive sorted ranges into a single sorted 
 range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#inplace_merge(short[], int, int, int, jal.SHORT.BinaryPredicate)">inplace_merge</A></B>(short[]&nbsp;array,
              int&nbsp;first,
              int&nbsp;middle,
              int&nbsp;last,
              <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms two consecutive sorted ranges into a single sorted 
 range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#insertion_sort(short[], int, int)">insertion_sort</A></B>(short[]&nbsp;array,
               int&nbsp;first,
               int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a range of elements by arithmetic comparison.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#insertion_sort(short[], int, int, jal.SHORT.BinaryPredicate)">insertion_sort</A></B>(short[]&nbsp;array,
               int&nbsp;first,
               int&nbsp;last,
               <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a range of elements by a user-supplied comparison function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#lexicographical_compare(short[], short[], int, int, int, int)">lexicographical_compare</A></B>(short[]&nbsp;array1,
                        short[]&nbsp;array2,
                        int&nbsp;first1,
                        int&nbsp;last1,
                        int&nbsp;first2,
                        int&nbsp;last2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a lexicographical (element-by-element) comparison of two ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#lexicographical_compare(short[], short[], int, int, int, int, jal.SHORT.BinaryPredicate)">lexicographical_compare</A></B>(short[]&nbsp;array1,
                        short[]&nbsp;array2,
                        int&nbsp;first1,
                        int&nbsp;last1,
                        int&nbsp;first2,
                        int&nbsp;last2,
                        <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a lexicographical (element-by-element) comparison of two ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short)">lower_bound</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            short&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range: finds the first
 position where an element can be inserted without violating the ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short, jal.SHORT.BinaryPredicate)">lower_bound</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            short&nbsp;x,
            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range: finds the first
 position where an element can be inserted without violating the ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int)">make_heap</A></B>(short[]&nbsp;array,
          int&nbsp;first,
          int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns the range <code>[first, last)</code> into a heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int, jal.SHORT.BinaryPredicate)">make_heap</A></B>(short[]&nbsp;array,
          int&nbsp;first,
          int&nbsp;last,
          <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns the range <code>[first, last)</code> into a heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#max_element(short[], int, int)">max_element</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the largest element in a range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#max_element(short[], int, int, jal.SHORT.BinaryPredicate)">max_element</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the largest element in a range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#merge(short[], short[], short[], int, int, int, int, int)">merge</A></B>(short[]&nbsp;source1,
      short[]&nbsp;source2,
      short[]&nbsp;dest,
      int&nbsp;first1,
      int&nbsp;last1,
      int&nbsp;first2,
      int&nbsp;last2,
      int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merges two sorted ranges into a third range, which will be sorted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#merge(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)">merge</A></B>(short[]&nbsp;source1,
      short[]&nbsp;source2,
      short[]&nbsp;dest,
      int&nbsp;first1,
      int&nbsp;last1,
      int&nbsp;first2,
      int&nbsp;last2,
      int&nbsp;to,
      <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Merges two sorted ranges into a third range, which will be sorted.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#min_element(short[], int, int)">min_element</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the smallest element in a range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#min_element(short[], int, int, jal.SHORT.BinaryPredicate)">min_element</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finds the smallest element in a range.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#next_permutation(short[], int, int)">next_permutation</A></B>(short[]&nbsp;array,
                 int&nbsp;first,
                 int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms a range of elements into the next permutation of those
 elements, where the <em>next</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#next_permutation(short[], int, int, jal.SHORT.BinaryPredicate)">next_permutation</A></B>(short[]&nbsp;array,
                 int&nbsp;first,
                 int&nbsp;last,
                 <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms a range of elements into the next permutation of those
 elements, where the <em>next</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#nth_element(short[], int, int, int)">nth_element</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;nth,
            int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partitions a range of elements into two subranges
 <code>[first, nth)</code> and <code>[nth, last)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#nth_element(short[], int, int, int, jal.SHORT.BinaryPredicate)">nth_element</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;nth,
            int&nbsp;last,
            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partitions a range of elements into two subranges
 <code>[first, nth)</code> and <code>[nth, last)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#partial_sort_copy(short[], short[], int, int, int, int)">partial_sort_copy</A></B>(short[]&nbsp;source,
                  short[]&nbsp;destination,
                  int&nbsp;first,
                  int&nbsp;last,
                  int&nbsp;result_first,
                  int&nbsp;result_last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the first <code>N</code> sorted elements from one range
 into another, where <code>N</code> is the length of the smaller of
 the two ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#partial_sort_copy(short[], short[], int, int, int, int, jal.SHORT.BinaryPredicate)">partial_sort_copy</A></B>(short[]&nbsp;source,
                  short[]&nbsp;destination,
                  int&nbsp;first,
                  int&nbsp;last,
                  int&nbsp;result_first,
                  int&nbsp;result_last,
                  <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies the first <code>N</code> sorted elements from one range
 into another, where <code>N</code> is the length of the smaller of
 the two ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#partial_sort(short[], int, int, int)">partial_sort</A></B>(short[]&nbsp;array,
             int&nbsp;first,
             int&nbsp;middle,
             int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partially sorts a range by arithmetic comparison: 
 places the first <code>middle-first</code> elements in the range 
 <code>[first, middle)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#partial_sort(short[], int, int, int, jal.SHORT.BinaryPredicate)">partial_sort</A></B>(short[]&nbsp;array,
             int&nbsp;first,
             int&nbsp;middle,
             int&nbsp;last,
             <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Partially sorts a range by a user-supplied comparison function:  
 places the first <code>middle-first</code> elements in the range 
 <code>[first, middle)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#pop_heap(short[], int, int)">pop_heap</A></B>(short[]&nbsp;array,
         int&nbsp;first,
         int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the largest element from a heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#pop_heap(short[], int, int, jal.SHORT.BinaryPredicate)">pop_heap</A></B>(short[]&nbsp;array,
         int&nbsp;first,
         int&nbsp;last,
         <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Removes the largest element from a heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#prev_permutation(short[], int, int)">prev_permutation</A></B>(short[]&nbsp;array,
                 int&nbsp;first,
                 int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms a range of elements into the previous permutation of those
 elements, where the <em>previous</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#prev_permutation(short[], int, int, jal.SHORT.BinaryPredicate)">prev_permutation</A></B>(short[]&nbsp;array,
                 int&nbsp;first,
                 int&nbsp;last,
                 <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Transforms a range of elements into the previous permutation of those
 elements, where the <em>previous</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#push_heap(short[], int, int)">push_heap</A></B>(short[]&nbsp;array,
          int&nbsp;first,
          int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an element to a heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#push_heap(short[], int, int, jal.SHORT.BinaryPredicate)">push_heap</A></B>(short[]&nbsp;array,
          int&nbsp;first,
          int&nbsp;last,
          <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds an element to a heap.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)">set_difference</A></B>(short[]&nbsp;source1,
               short[]&nbsp;source2,
               short[]&nbsp;destination,
               int&nbsp;first1,
               int&nbsp;last1,
               int&nbsp;first2,
               int&nbsp;last2,
               int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs the set difference of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)">set_difference</A></B>(short[]&nbsp;source1,
               short[]&nbsp;source2,
               short[]&nbsp;destination,
               int&nbsp;first1,
               int&nbsp;last1,
               int&nbsp;first2,
               int&nbsp;last2,
               int&nbsp;to,
               <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs the set difference of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)">set_intersection</A></B>(short[]&nbsp;source1,
                 short[]&nbsp;source2,
                 short[]&nbsp;destination,
                 int&nbsp;first1,
                 int&nbsp;last1,
                 int&nbsp;first2,
                 int&nbsp;last2,
                 int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an intersection of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)">set_intersection</A></B>(short[]&nbsp;source1,
                 short[]&nbsp;source2,
                 short[]&nbsp;destination,
                 int&nbsp;first1,
                 int&nbsp;last1,
                 int&nbsp;first2,
                 int&nbsp;last2,
                 int&nbsp;to,
                 <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs an intersection of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)">set_symmetric_difference</A></B>(short[]&nbsp;source1,
                         short[]&nbsp;source2,
                         short[]&nbsp;destination,
                         int&nbsp;first1,
                         int&nbsp;last1,
                         int&nbsp;first2,
                         int&nbsp;last2,
                         int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs the set symmetric difference of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)">set_symmetric_difference</A></B>(short[]&nbsp;source1,
                         short[]&nbsp;source2,
                         short[]&nbsp;destination,
                         int&nbsp;first1,
                         int&nbsp;last1,
                         int&nbsp;first2,
                         int&nbsp;last2,
                         int&nbsp;to,
                         <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs the set symmetric difference of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)">set_union</A></B>(short[]&nbsp;source1,
          short[]&nbsp;source2,
          short[]&nbsp;destination,
          int&nbsp;first1,
          int&nbsp;last1,
          int&nbsp;first2,
          int&nbsp;last2,
          int&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a union of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)">set_union</A></B>(short[]&nbsp;source1,
          short[]&nbsp;source2,
          short[]&nbsp;destination,
          int&nbsp;first1,
          int&nbsp;last1,
          int&nbsp;first2,
          int&nbsp;last2,
          int&nbsp;to,
          <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructs a union of two already-sorted ranges.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#sort_heap(short[], int, int)">sort_heap</A></B>(short[]&nbsp;array,
          int&nbsp;first,
          int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns a heap into a sorted range; this operation is
 <code>O(N log N)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#sort_heap(short[], int, int, jal.SHORT.BinaryPredicate)">sort_heap</A></B>(short[]&nbsp;array,
          int&nbsp;first,
          int&nbsp;last,
          <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Turns a heap into a sorted range; this operation is
 <code>O(N log N)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int)">sort</A></B>(short[]&nbsp;array,
     int&nbsp;first,
     int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a range of elements by arithmetic comparison.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int, jal.SHORT.BinaryPredicate)">sort</A></B>(short[]&nbsp;array,
     int&nbsp;first,
     int&nbsp;last,
     <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a range of elements by a user-supplied comparison function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#stable_sort(short[], int, int)">stable_sort</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a range of elements by arithmetic comparison.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#stable_sort(short[], int, int, jal.SHORT.BinaryPredicate)">stable_sort</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sort a range of elements by a user-supplied comparison function.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short)">upper_bound</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            short&nbsp;x)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range: finds the last
 position where an element can be inserted without violating the ordering.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short, jal.SHORT.BinaryPredicate)">upper_bound</A></B>(short[]&nbsp;array,
            int&nbsp;first,
            int&nbsp;last,
            short&nbsp;x,
            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Performs a binary search on an already-sorted range: finds the last
 position where an element can be inserted without violating the ordering.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#getClass()">getClass</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#notify()">notify</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#toString()">toString</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#wait()">wait</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#wait(long)">wait</A>, <A HREF="http://java.sun.com/j2se/1.4.1/docs/api/java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="sort(short[], int, int)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;array,
                        int&nbsp;first,
                        int&nbsp;last)</PRE>
<DL>
<DD>Sort a range of elements by arithmetic comparison.  
 Uses the quicksort algorithm.  Average 
 performance goes as <code>N log N</code>; worst-case performance
 is quadratic, but this case is extremely rare.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#stable_sort(short[], int, int)"><CODE>stable_sort(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#insertion_sort(short[], int, int)"><CODE>insertion_sort(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#partial_sort(short[], int, int, int)"><CODE>partial_sort(short[], int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sort(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
sort</H3>
<PRE>
public static void <B>sort</B>(short[]&nbsp;array,
                        int&nbsp;first,
                        int&nbsp;last,
                        <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Sort a range of elements by a user-supplied comparison function.
 Uses the quicksort algorithm.  Average 
 performance goes as <code>N log N</code>; worst-case performance
 is quadratic, but this case is extremely rare.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#stable_sort(short[], int, int)"><CODE>stable_sort(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#insertion_sort(short[], int, int)"><CODE>insertion_sort(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#partial_sort(short[], int, int, int)"><CODE>partial_sort(short[], int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="insertion_sort(short[], int, int)"><!-- --></A><H3>
insertion_sort</H3>
<PRE>
public static void <B>insertion_sort</B>(short[]&nbsp;array,
                                  int&nbsp;first,
                                  int&nbsp;last)</PRE>
<DL>
<DD>Sort a range of elements by arithmetic comparison.  
 Uses the insertion sort algorithm.  This is a quadratic
 algorithm, but it is useful for sorting small numbers of elements.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int)"><CODE>sort(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="insertion_sort(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
insertion_sort</H3>
<PRE>
public static void <B>insertion_sort</B>(short[]&nbsp;array,
                                  int&nbsp;first,
                                  int&nbsp;last,
                                  <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Sort a range of elements by a user-supplied comparison function.
 Uses the insertion sort algorithm.  This is a quadratic
 algorithm, but it is useful for sorting small numbers of elements.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int)"><CODE>sort(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stable_sort(short[], int, int)"><!-- --></A><H3>
stable_sort</H3>
<PRE>
public static void <B>stable_sort</B>(short[]&nbsp;array,
                               int&nbsp;first,
                               int&nbsp;last)</PRE>
<DL>
<DD>Sort a range of elements by arithmetic comparison.  
 The sort is stable---that is, the relative order of equal elements
 is unchanged.  Worst case performance is <code>N (log N)^2</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int)"><CODE>sort(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="stable_sort(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
stable_sort</H3>
<PRE>
public static void <B>stable_sort</B>(short[]&nbsp;array,
                               int&nbsp;first,
                               int&nbsp;last,
                               <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Sort a range of elements by a user-supplied comparison function.
 The sort is stable---that is, the relative order of equal elements
 is unchanged.  Worst case performance is <code>N (log N)^2</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int)"><CODE>sort(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="partial_sort(short[], int, int, int)"><!-- --></A><H3>
partial_sort</H3>
<PRE>
public static void <B>partial_sort</B>(short[]&nbsp;array,
                                int&nbsp;first,
                                int&nbsp;middle,
                                int&nbsp;last)</PRE>
<DL>
<DD>Partially sorts a range by arithmetic comparison: 
 places the first <code>middle-first</code> elements in the range 
 <code>[first, middle)</code>.  These elements are sorted, the rest
 are not.  It is not guaranteed that the relative ordering of 
 unsorted elements is preserved.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>middle</CODE> - Element such that the range
                    <code>[first, middle)</code> will be sorted.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#partial_sort_copy(short[], short[], int, int, int, int)"><CODE>partial_sort_copy(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int)"><CODE>sort(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="partial_sort(short[], int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
partial_sort</H3>
<PRE>
public static void <B>partial_sort</B>(short[]&nbsp;array,
                                int&nbsp;first,
                                int&nbsp;middle,
                                int&nbsp;last,
                                <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Partially sorts a range by a user-supplied comparison function:  
 places the first <code>middle-first</code> elements in the range 
 <code>[first, middle)</code>.  These elements are sorted, the rest
 are not.  It is not guaranteed that the relative ordering of 
 unsorted elements is preserved.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>middle</CODE> - Element such that the range
                    <code>[first, middle)</code> will be sorted.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#partial_sort_copy(short[], short[], int, int, int, int)"><CODE>partial_sort_copy(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#sort(short[], int, int)"><CODE>sort(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="partial_sort_copy(short[], short[], int, int, int, int)"><!-- --></A><H3>
partial_sort_copy</H3>
<PRE>
public static int <B>partial_sort_copy</B>(short[]&nbsp;source,
                                    short[]&nbsp;destination,
                                    int&nbsp;first,
                                    int&nbsp;last,
                                    int&nbsp;result_first,
                                    int&nbsp;result_last)</PRE>
<DL>
<DD>Copies the first <code>N</code> sorted elements from one range
 into another, where <code>N</code> is the length of the smaller of
 the two ranges.  Sort order is by arithmetic comparison.
 Existing elements in the output range will be overwritten.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - Array containing the input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first</CODE> - Beginning of the input range.<DD><CODE>last</CODE> - One past the end of the input range.<DD><CODE>result_first</CODE> - Beginning of the output range.<DD><CODE>result_last</CODE> - One past the end of the output range.<DT><B>Returns:</B><DD><code>result_first + N</code>, where
                     <code>N = min(last-first, result_last-result_first)</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#partial_sort(short[], int, int, int)"><CODE>partial_sort(short[], int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="partial_sort_copy(short[], short[], int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
partial_sort_copy</H3>
<PRE>
public static int <B>partial_sort_copy</B>(short[]&nbsp;source,
                                    short[]&nbsp;destination,
                                    int&nbsp;first,
                                    int&nbsp;last,
                                    int&nbsp;result_first,
                                    int&nbsp;result_last,
                                    <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Copies the first <code>N</code> sorted elements from one range
 into another, where <code>N</code> is the length of the smaller of
 the two ranges.  Sort order is by a user-supplied comparison function.
 Existing elements in the output range will be overwritten.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source</CODE> - Array containing the input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first</CODE> - Beginning of the input range.<DD><CODE>last</CODE> - One past the end of the input range.<DD><CODE>result_first</CODE> - Beginning of the output range.<DD><CODE>result_last</CODE> - One past the end of the output range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD><code>result_first + N</code>, where
                     <code>N = min(last-first, result_last-result_first)</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#partial_sort(short[], int, int, int)"><CODE>partial_sort(short[], int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="nth_element(short[], int, int, int)"><!-- --></A><H3>
nth_element</H3>
<PRE>
public static void <B>nth_element</B>(short[]&nbsp;array,
                               int&nbsp;first,
                               int&nbsp;nth,
                               int&nbsp;last)</PRE>
<DL>
<DD>Partitions a range of elements into two subranges
 <code>[first, nth)</code> and <code>[nth, last)</code>.  These
 satisfy the properties that no element in the first range is greater
 than any element in the second, and that the element in the
 position <code>nth</code> is the same as the one that would be
 in that position if the entire range <code>[first, last)</code>
 had been sorted.  Sorting is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>nth</CODE> - Location of the partition point.<DD><CODE>last</CODE> - One past the end of the range.</DL>
</DD>
</DL>
<HR>

<A NAME="nth_element(short[], int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
nth_element</H3>
<PRE>
public static void <B>nth_element</B>(short[]&nbsp;array,
                               int&nbsp;first,
                               int&nbsp;nth,
                               int&nbsp;last,
                               <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Partitions a range of elements into two subranges
 <code>[first, nth)</code> and <code>[nth, last)</code>.  These
 satisfy the properties that no element in the first range is greater
 than any element in the second, and that the element in the
 position <code>nth</code> is the same as the one that would be
 in that position if the entire range <code>[first, last)</code>
 had been sorted.  Sorting is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>nth</CODE> - Location of the partition point.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function.</DL>
</DD>
</DL>
<HR>

<A NAME="lower_bound(short[], int, int, short)"><!-- --></A><H3>
lower_bound</H3>
<PRE>
public static int <B>lower_bound</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last,
                              short&nbsp;x)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range: finds the first
 position where an element can be inserted without violating the ordering.
 Sorting is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>x</CODE> - Element to be searched for.<DT><B>Returns:</B><DD>The largest index i such that, for every j in the
                 range <code>[first, i)</code>, 
                 <code>array[j] &lt; x</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short)"><CODE>upper_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short)"><CODE>equal_range(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short)"><CODE>binary_search(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lower_bound(short[], int, int, short, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
lower_bound</H3>
<PRE>
public static int <B>lower_bound</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last,
                              short&nbsp;x,
                              <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range: finds the first
 position where an element can be inserted without violating the ordering.
 Sorting is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>x</CODE> - Element to be searched for.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD>The largest index i such that, for every j in the
                 range <code>[first, i)</code>, 
                 <code>comp.apply(array[j], x)</code> is
                 <code>true</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short)"><CODE>upper_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short)"><CODE>equal_range(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short)"><CODE>binary_search(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="upper_bound(short[], int, int, short)"><!-- --></A><H3>
upper_bound</H3>
<PRE>
public static int <B>upper_bound</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last,
                              short&nbsp;x)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range: finds the last
 position where an element can be inserted without violating the ordering.
 Sorting is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range<DD><CODE>first</CODE> - Beginning of the range<DD><CODE>last</CODE> - One past the end of the range<DD><CODE>x</CODE> - Element to be searched for<DT><B>Returns:</B><DD>The largest index i such that, for every j in the
                 range <code>[first, i)</code>, 
                 <code>!(x &lt; array[j])</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short)"><CODE>lower_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short)"><CODE>equal_range(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short)"><CODE>binary_search(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="upper_bound(short[], int, int, short, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
upper_bound</H3>
<PRE>
public static int <B>upper_bound</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last,
                              short&nbsp;x,
                              <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range: finds the last
 position where an element can be inserted without violating the ordering.
 Sorting is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>x</CODE> - Element to be searched for.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD>The largest index i such that, for every j in the
                 range <code>[first, i)</code>, 
                 <code>comp.apply(x, array[j])</code> is 
                 <code>false</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short)"><CODE>lower_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short)"><CODE>equal_range(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short)"><CODE>binary_search(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equal_range(short[], int, int, short)"><!-- --></A><H3>
equal_range</H3>
<PRE>
public static <A HREF="../../jal/SHORT/Range.html">Range</A> <B>equal_range</B>(short[]&nbsp;array,
                                int&nbsp;first,
                                int&nbsp;last,
                                short&nbsp;x)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range:
 Finds the largest subrange in the supplied range such that an
 element can be inserted at any point in that subrange without violating
 the existing ordering.  Sorting is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>x</CODE> - Element to be searched for.<DT><B>Returns:</B><DD>An object <code>R</code>of class <code>R</code> such 
                 that, for any index <code>i</code> in the range
                 <code>[R.first, R.last)</code>, the conditions
                 <code>array[i] &lt; x</code> and
                 <code>x &lt; array[i]</code> are both false.
                 Note that it is possible for the return value to be
                 an empty range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short)"><CODE>lower_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short)"><CODE>upper_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short)"><CODE>binary_search(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="equal_range(short[], int, int, short, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
equal_range</H3>
<PRE>
public static <A HREF="../../jal/SHORT/Range.html">Range</A> <B>equal_range</B>(short[]&nbsp;array,
                                int&nbsp;first,
                                int&nbsp;last,
                                short&nbsp;x,
                                <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range:
 Finds the largest subrange in the supplied range such that an
 element can be inserted at any point in that subrange without violating
 the existing ordering.  
 Sorting is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>x</CODE> - Element to be searched for.<DD><CODE>comp</CODE> - Comparison function<DT><B>Returns:</B><DD>An object <code>R</code>of class <code>R</code> such 
                 that, for any index <code>i</code> in the range
                 <code>[R.first, R.last)</code>, the conditions
                 <code>comp.apply(array[i], x)</code> and
                 <code>comp.apply(x, array[i])</code> are both false.
                 Note that it is possible for the return value to be
                 an empty range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short)"><CODE>lower_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short)"><CODE>upper_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#binary_search(short[], int, int, short)"><CODE>binary_search(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binary_search(short[], int, int, short)"><!-- --></A><H3>
binary_search</H3>
<PRE>
public static boolean <B>binary_search</B>(short[]&nbsp;array,
                                    int&nbsp;first,
                                    int&nbsp;last,
                                    short&nbsp;x)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range:
 determines whether the range contains an element equivalent to a
 certain value.
 Sorting is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>x</CODE> - Element to be searched for.<DT><B>Returns:</B><DD><code>true</code> if and only if the range contains 
                 an element <code>E</code> such that 
                 <code>value &lt; E</code> and
                 <code>E &lt; value</code> are both 
                 <code>false</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short)"><CODE>lower_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short)"><CODE>upper_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short)"><CODE>equal_range(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="binary_search(short[], int, int, short, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
binary_search</H3>
<PRE>
public static boolean <B>binary_search</B>(short[]&nbsp;array,
                                    int&nbsp;first,
                                    int&nbsp;last,
                                    short&nbsp;x,
                                    <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Performs a binary search on an already-sorted range:
 determines whether the range contains an element equivalent to a
 certain value.
 Sorting is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>x</CODE> - Element to be searched for.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD><code>true</code> if and only if the range contains 
                 an element <code>E</code> such that 
                 <code>value &lt; E</code> and
                 <code>E &lt; value</code> are both 
                 <code>false</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lower_bound(short[], int, int, short)"><CODE>lower_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#upper_bound(short[], int, int, short)"><CODE>upper_bound(short[], int, int, short)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#equal_range(short[], int, int, short)"><CODE>equal_range(short[], int, int, short)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="merge(short[], short[], short[], int, int, int, int, int)"><!-- --></A><H3>
merge</H3>
<PRE>
public static int <B>merge</B>(short[]&nbsp;source1,
                        short[]&nbsp;source2,
                        short[]&nbsp;dest,
                        int&nbsp;first1,
                        int&nbsp;last1,
                        int&nbsp;first2,
                        int&nbsp;last2,
                        int&nbsp;to)</PRE>
<DL>
<DD>Merges two sorted ranges into a third range, which will be sorted.
 Elements in the first input range will precede equal elements in the 
 second.
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by arithmetic comparison.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>dest</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DD><CODE>return</CODE> - One past the end of the output range, that is,
                    <code>to + (last1-first1) + (last2-first2)</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#inplace_merge(short[], int, int, int)"><CODE>inplace_merge(short[], int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="merge(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
merge</H3>
<PRE>
public static int <B>merge</B>(short[]&nbsp;source1,
                        short[]&nbsp;source2,
                        short[]&nbsp;dest,
                        int&nbsp;first1,
                        int&nbsp;last1,
                        int&nbsp;first2,
                        int&nbsp;last2,
                        int&nbsp;to,
                        <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Merges two sorted ranges into a third range, which will be sorted.
 Elements in the first input range will precede equal elements in the 
 second.
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by a user-supplied comparison function.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>dest</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DD><CODE>comp</CODE> - Comparison function<DT><B>Returns:</B><DD>One past the end of the output range, that is,
                    <code>to + (last1-first1) + (last2-first2)</code>.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#inplace_merge(short[], int, int, int)"><CODE>inplace_merge(short[], int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="inplace_merge(short[], int, int, int)"><!-- --></A><H3>
inplace_merge</H3>
<PRE>
public static void <B>inplace_merge</B>(short[]&nbsp;array,
                                 int&nbsp;first,
                                 int&nbsp;middle,
                                 int&nbsp;last)</PRE>
<DL>
<DD>Transforms two consecutive sorted ranges into a single sorted 
 range.  The initial ranges are <code>[first, middle)</code>
 and <code>[middle, last)</code>, and the resulting range is
 <code>[first, last)</code>.  
 Elements in the first input range will precede equal elements in the 
 second.
 Sorting is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the ranges.<DD><CODE>first</CODE> - Beginning of the first range.<DD><CODE>middle</CODE> - One past the end of the first range, and beginning
                 of the second.<DD><CODE>last</CODE> - One past the end of the second range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#merge(short[], short[], short[], int, int, int, int, int)"><CODE>merge(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="inplace_merge(short[], int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
inplace_merge</H3>
<PRE>
public static void <B>inplace_merge</B>(short[]&nbsp;array,
                                 int&nbsp;first,
                                 int&nbsp;middle,
                                 int&nbsp;last,
                                 <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Transforms two consecutive sorted ranges into a single sorted 
 range.  The initial ranges are <code>[first, middle)</code>
 and <code>[middle, last)</code>, and the resulting range is
 <code>[first, last)</code>.  
 Elements in the first input range will precede equal elements in the 
 second.
 Sorting is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the ranges.<DD><CODE>first</CODE> - Beginning of the first range.<DD><CODE>middle</CODE> - One past the end of the first range, and beginning
                 of the second.<DD><CODE>last</CODE> - One past the end of the second range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#merge(short[], short[], short[], int, int, int, int, int)"><CODE>merge(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="includes(short[], short[], int, int, int, int)"><!-- --></A><H3>
includes</H3>
<PRE>
public static boolean <B>includes</B>(short[]&nbsp;array1,
                               short[]&nbsp;array2,
                               int&nbsp;first1,
                               int&nbsp;last1,
                               int&nbsp;first2,
                               int&nbsp;last2)</PRE>
<DL>
<DD>Tests whether the first range is a superset of the second; both ranges
 must be sorted.
 Sorting is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array1</CODE> - Array containing the first range.<DD><CODE>array2</CODE> - Array containing the second range.<DD><CODE>first1</CODE> - Beginning of the first range.<DD><CODE>last1</CODE> - One past the end of the first range.<DD><CODE>first2</CODE> - Beginning of the second range.<DD><CODE>last2</CODE> - One past the end of the second range.<DT><B>Returns:</B><DD><code>true</code> if and only if, for every element in
                 the range <code>[first2,last2)</code>, the range
                 <code>[first1,last1)</code> contains an equivalent 
                 element.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="includes(short[], short[], int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
includes</H3>
<PRE>
public static boolean <B>includes</B>(short[]&nbsp;array1,
                               short[]&nbsp;array2,
                               int&nbsp;first1,
                               int&nbsp;last1,
                               int&nbsp;first2,
                               int&nbsp;last2,
                               <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Tests whether the first range is a superset of the second; both ranges
 must be sorted.
 Sorting is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array1</CODE> - Array containing the first range.<DD><CODE>array2</CODE> - Array containing the second range.<DD><CODE>first1</CODE> - Beginning of the first range.<DD><CODE>last1</CODE> - One past the end of the first range.<DD><CODE>first2</CODE> - Beginning of the second range.<DD><CODE>last2</CODE> - One past the end of the second range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD><code>true</code> if and only if, for every element in
                 the range <code>[first2,last2)</code>, the range
                 <code>[first1,last1)</code> contains an equivalent 
                 element.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_union(short[], short[], short[], int, int, int, int, int)"><!-- --></A><H3>
set_union</H3>
<PRE>
public static int <B>set_union</B>(short[]&nbsp;source1,
                            short[]&nbsp;source2,
                            short[]&nbsp;destination,
                            int&nbsp;first1,
                            int&nbsp;last1,
                            int&nbsp;first2,
                            int&nbsp;last2,
                            int&nbsp;to)</PRE>
<DL>
<DD>Constructs a union of two already-sorted ranges.  That is, 
 the output range will be a sorted range containing every element from
 either of the two input ranges.  If an element in the second range
 is equivalent to one in the first, the one in the first range is
 copied.  
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by arithmetic comparison.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_union(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
set_union</H3>
<PRE>
public static int <B>set_union</B>(short[]&nbsp;source1,
                            short[]&nbsp;source2,
                            short[]&nbsp;destination,
                            int&nbsp;first1,
                            int&nbsp;last1,
                            int&nbsp;first2,
                            int&nbsp;last2,
                            int&nbsp;to,
                            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Constructs a union of two already-sorted ranges.  That is, 
 the output range will be a sorted range containing every element from
 either of the two input ranges.  If an element in the second range
 is equivalent to one in the first, the one in the first range is
 copied.  
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by a user-provided comparison function.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DD><CODE>comp</CODE> - Comparison function<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_intersection(short[], short[], short[], int, int, int, int, int)"><!-- --></A><H3>
set_intersection</H3>
<PRE>
public static int <B>set_intersection</B>(short[]&nbsp;source1,
                                   short[]&nbsp;source2,
                                   short[]&nbsp;destination,
                                   int&nbsp;first1,
                                   int&nbsp;last1,
                                   int&nbsp;first2,
                                   int&nbsp;last2,
                                   int&nbsp;to)</PRE>
<DL>
<DD>Constructs an intersection of two already-sorted ranges.  That is, 
 the output range will be a sorted range containing every element from
 the first range such that an equivelent element exists in the
 second range.  
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by arithmetic comparison.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_intersection(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
set_intersection</H3>
<PRE>
public static int <B>set_intersection</B>(short[]&nbsp;source1,
                                   short[]&nbsp;source2,
                                   short[]&nbsp;destination,
                                   int&nbsp;first1,
                                   int&nbsp;last1,
                                   int&nbsp;first2,
                                   int&nbsp;last2,
                                   int&nbsp;to,
                                   <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Constructs an intersection of two already-sorted ranges.  That is, 
 the output range will be a sorted range containing every element from
 the first range such that an equivelent element exists in the
 second range.  
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by a user-provided comparison function.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DD><CODE>comp</CODE> - Comparison function<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_difference(short[], short[], short[], int, int, int, int, int)"><!-- --></A><H3>
set_difference</H3>
<PRE>
public static int <B>set_difference</B>(short[]&nbsp;source1,
                                 short[]&nbsp;source2,
                                 short[]&nbsp;destination,
                                 int&nbsp;first1,
                                 int&nbsp;last1,
                                 int&nbsp;first2,
                                 int&nbsp;last2,
                                 int&nbsp;to)</PRE>
<DL>
<DD>Constructs the set difference of two already-sorted ranges.  That is, 
 the output range will be a sorted range containing every element from
 the first range such that an equivelent element does not exist in the
 second range.  
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by arithmetic comparison.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_difference(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
set_difference</H3>
<PRE>
public static int <B>set_difference</B>(short[]&nbsp;source1,
                                 short[]&nbsp;source2,
                                 short[]&nbsp;destination,
                                 int&nbsp;first1,
                                 int&nbsp;last1,
                                 int&nbsp;first2,
                                 int&nbsp;last2,
                                 int&nbsp;to,
                                 <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Constructs the set difference of two already-sorted ranges.  That is, 
 the output range will be a sorted range containing every element from
 the first range such that an equivelent element does not exist in the
 second range.  
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by a user-supplied comparison function.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_symmetric_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_symmetric_difference(short[], short[], short[], int, int, int, int, int)"><!-- --></A><H3>
set_symmetric_difference</H3>
<PRE>
public static int <B>set_symmetric_difference</B>(short[]&nbsp;source1,
                                           short[]&nbsp;source2,
                                           short[]&nbsp;destination,
                                           int&nbsp;first1,
                                           int&nbsp;last1,
                                           int&nbsp;first2,
                                           int&nbsp;last2,
                                           int&nbsp;to)</PRE>
<DL>
<DD>Constructs the set symmetric difference of two already-sorted ranges.  
 That is,  the output range will be a sorted range containing every
 element from the first range such that an equivelent element does not 
 exist in the second range, and every element in the second such that an
 equivalent element does not exist in the first.
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by arithmetic comparison.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="set_symmetric_difference(short[], short[], short[], int, int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
set_symmetric_difference</H3>
<PRE>
public static int <B>set_symmetric_difference</B>(short[]&nbsp;source1,
                                           short[]&nbsp;source2,
                                           short[]&nbsp;destination,
                                           int&nbsp;first1,
                                           int&nbsp;last1,
                                           int&nbsp;first2,
                                           int&nbsp;last2,
                                           int&nbsp;to,
                                           <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Constructs the set symmetric difference of two already-sorted ranges.  
 That is,  the output range will be a sorted range containing every
 element from the first range such that an equivelent element does not 
 exist in the second range, and every element in the second such that an
 equivalent element does not exist in the first.
 There must be
 enough space in the destination array, and existing elements 
 will be overwritten.
 Sorting is by a user-supplied comparison function.
 Note: the destination range is not permitted to overlap either of 
 the two input ranges.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>source1</CODE> - Array containing the first input range.<DD><CODE>source2</CODE> - Array containing the second input range.<DD><CODE>destination</CODE> - Array containing the output range.<DD><CODE>first1</CODE> - Beginning of the first input range.<DD><CODE>last1</CODE> - One past the end of the first input range.<DD><CODE>first2</CODE> - Beginning of the second input range.<DD><CODE>last2</CODE> - One past the end of the second input range.<DD><CODE>to</CODE> - Beginning of the output range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD>One past the end of the output range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#includes(short[], short[], int, int, int, int)"><CODE>includes(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_union(short[], short[], short[], int, int, int, int, int)"><CODE>set_union(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_intersection(short[], short[], short[], int, int, int, int, int)"><CODE>set_intersection(short[], short[], short[], int, int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#set_difference(short[], short[], short[], int, int, int, int, int)"><CODE>set_difference(short[], short[], short[], int, int, int, int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="push_heap(short[], int, int)"><!-- --></A><H3>
push_heap</H3>
<PRE>
public static void <B>push_heap</B>(short[]&nbsp;array,
                             int&nbsp;first,
                             int&nbsp;last)</PRE>
<DL>
<DD>Adds an element to a heap.  The range <code>[first, last-1)</code>
 must be a valid heap, and the element to be added must be in
 <code>array[last-1]</code>.  
 The heap is ordered by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the heap.<DD><CODE>first</CODE> - Beginning of the heap.<DD><CODE>last</CODE> - Index such that <code>[first, last-1)</code> is a
                 valid heap and such that <code>array[last-1]</code> 
                 contains the element to be added to the heap.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int)"><CODE>make_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="push_heap(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
push_heap</H3>
<PRE>
public static void <B>push_heap</B>(short[]&nbsp;array,
                             int&nbsp;first,
                             int&nbsp;last,
                             <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Adds an element to a heap.  The range <code>[first, last-1)</code>
 must be a valid heap, and the element to be added must be in
 <code>array[last-1]</code>.  
 The heap is ordered by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the heap.<DD><CODE>first</CODE> - Beginning of the heap.<DD><CODE>last</CODE> - Index such that <code>[first, last-1)</code> is a
                 valid heap and such that <code>array[last-1]</code> 
                 contains the element to be added to the heap.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int)"><CODE>make_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="pop_heap(short[], int, int)"><!-- --></A><H3>
pop_heap</H3>
<PRE>
public static void <B>pop_heap</B>(short[]&nbsp;array,
                            int&nbsp;first,
                            int&nbsp;last)</PRE>
<DL>
<DD>Removes the largest element from a heap.  If the range 
 <code>[first, last)</code> is a valid heap, then remove
 <code>array[first]</code> (the largest element) from the heap,
 rearrange elements such that <code>[first, last-1)</code> is
 a valid heap, and place the removed element in <code>array[last]</code>.
 The heap is ordered by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the heap.<DD><CODE>first</CODE> - Beginning of the heap.<DD><CODE>last</CODE> - One past the end of the heap.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int)"><CODE>make_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="pop_heap(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
pop_heap</H3>
<PRE>
public static void <B>pop_heap</B>(short[]&nbsp;array,
                            int&nbsp;first,
                            int&nbsp;last,
                            <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Removes the largest element from a heap.  If the range 
 <code>[first, last)</code> is a valid heap, then remove
 <code>array[first]</code> (the largest element) from the heap,
 rearrange elements such that <code>[first, last-1)</code> is
 a valid heap, and place the removed element in <code>array[last]</code>.
 The heap is ordered by a user-defined comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the heap.<DD><CODE>first</CODE> - Beginning of the heap.<DD><CODE>last</CODE> - One past the end of the heap.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int)"><CODE>make_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="make_heap(short[], int, int)"><!-- --></A><H3>
make_heap</H3>
<PRE>
public static void <B>make_heap</B>(short[]&nbsp;array,
                             int&nbsp;first,
                             int&nbsp;last)</PRE>
<DL>
<DD>Turns the range <code>[first, last)</code> into a heap.  A heap has
 the properties that <code>array[first]</code> is the largest element,
 and that it is possible to add a new element, or to remove 
 <code>array[first]</code>, efficiently.
 The heap is ordered by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range that is to be made a heap.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#push_heap(short[], int, int)"><CODE>push_heap(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#pop_heap(short[], int, int)"><CODE>pop_heap(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#sort_heap(short[], int, int)"><CODE>sort_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="make_heap(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
make_heap</H3>
<PRE>
public static void <B>make_heap</B>(short[]&nbsp;array,
                             int&nbsp;first,
                             int&nbsp;last,
                             <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Turns the range <code>[first, last)</code> into a heap.  A heap has
 the properties that <code>array[first]</code> is the largest element,
 and that it is possible to add a new element, or to remove 
 <code>array[first]</code>, efficiently.
 The heap is ordered by a user-defined comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range that is to be made a heap.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#push_heap(short[], int, int)"><CODE>push_heap(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#pop_heap(short[], int, int)"><CODE>pop_heap(short[], int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#sort_heap(short[], int, int)"><CODE>sort_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sort_heap(short[], int, int)"><!-- --></A><H3>
sort_heap</H3>
<PRE>
public static void <B>sort_heap</B>(short[]&nbsp;array,
                             int&nbsp;first,
                             int&nbsp;last)</PRE>
<DL>
<DD>Turns a heap into a sorted range; this operation is
 <code>O(N log N)</code>.  Note that <code>make_heap</code>
 followed by <code>sort_heap</code> is the heap sort algorithm.
 Ordering is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the heap that is to be made a sorted
                 range.<DD><CODE>first</CODE> - Beginning of the heap.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int)"><CODE>make_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="sort_heap(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
sort_heap</H3>
<PRE>
public static void <B>sort_heap</B>(short[]&nbsp;array,
                             int&nbsp;first,
                             int&nbsp;last,
                             <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Turns a heap into a sorted range; this operation is
 <code>O(N log N)</code>.  Note that <code>make_heap</code>
 followed by <code>sort_heap</code> is the heap sort algorithm.
 Ordering is by a user-supplied comparision function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the heap that is to be made a sorted
                 range.<DD><CODE>first</CODE> - Beginning of the heap.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#make_heap(short[], int, int)"><CODE>make_heap(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="max_element(short[], int, int)"><!-- --></A><H3>
max_element</H3>
<PRE>
public static int <B>max_element</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last)</PRE>
<DL>
<DD>Finds the largest element in a range.
 Ordering is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - End of the range.<DT><B>Returns:</B><DD>The smallest index <code>i</code> such that every element
                 in the range is less than or equivalent to 
                 <code>array[i]</code>.  Returns <code>last</code>
                 if the range is empty.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#min_element(short[], int, int)"><CODE>min_element(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="max_element(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
max_element</H3>
<PRE>
public static int <B>max_element</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last,
                              <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Finds the largest element in a range.
 Ordering is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - End of the range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD>The smallest index <code>i</code> such that every element
                 in the range is less than or equivalent to 
                 <code>array[i]</code>.  Returns <code>last</code>
                 if the range is empty.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#min_element(short[], int, int)"><CODE>min_element(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="min_element(short[], int, int)"><!-- --></A><H3>
min_element</H3>
<PRE>
public static int <B>min_element</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last)</PRE>
<DL>
<DD>Finds the smallest element in a range.
 Ordering is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range<DD><CODE>first</CODE> - Beginning of the range<DD><CODE>last</CODE> - End of the range<DT><B>Returns:</B><DD>The smallest index <code>i</code> such that every element
                 in the range is greater than or equivalent to 
                 <code>array[i]</code>.  Returns <code>last</code>
                 if the range is empty.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#max_element(short[], int, int)"><CODE>max_element(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="min_element(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
min_element</H3>
<PRE>
public static int <B>min_element</B>(short[]&nbsp;array,
                              int&nbsp;first,
                              int&nbsp;last,
                              <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Finds the smallest element in a range.
 Ordering is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range<DD><CODE>first</CODE> - Beginning of the range<DD><CODE>last</CODE> - End of the range<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD>The smallest index <code>i</code> such that every element
                 in the range is greater than or equivalent to 
                 <code>array[i]</code>.  Returns <code>last</code>
                 if the range is empty.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#max_element(short[], int, int)"><CODE>max_element(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="lexicographical_compare(short[], short[], int, int, int, int)"><!-- --></A><H3>
lexicographical_compare</H3>
<PRE>
public static boolean <B>lexicographical_compare</B>(short[]&nbsp;array1,
                                              short[]&nbsp;array2,
                                              int&nbsp;first1,
                                              int&nbsp;last1,
                                              int&nbsp;first2,
                                              int&nbsp;last2)</PRE>
<DL>
<DD>Performs a lexicographical (element-by-element) comparison of two ranges.
 Ordering of individual elements is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array1</CODE> - Array containing the first range.<DD><CODE>array2</CODE> - Array containing the second range.<DD><CODE>first1</CODE> - Beginning of the first range.<DD><CODE>last1</CODE> - One past the end of the first range.<DD><CODE>first2</CODE> - Beginning of the second range.<DD><CODE>last2</CODE> - One past the end of the second range.<DT><B>Returns:</B><DD><code>true</code> if the sequence of elements in the
                  range <code>[first1, last1)</code> is lexicographically
                  less than that in <code>[first1, last1)</code>,
                  otherwise <code>false</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="lexicographical_compare(short[], short[], int, int, int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
lexicographical_compare</H3>
<PRE>
public static boolean <B>lexicographical_compare</B>(short[]&nbsp;array1,
                                              short[]&nbsp;array2,
                                              int&nbsp;first1,
                                              int&nbsp;last1,
                                              int&nbsp;first2,
                                              int&nbsp;last2,
                                              <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Performs a lexicographical (element-by-element) comparison of two ranges.
 Ordering of individual elements is by a user-supplied comparison function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array1</CODE> - Array containing the first range.<DD><CODE>array2</CODE> - Array containing the second range.<DD><CODE>first1</CODE> - Beginning of the first range.<DD><CODE>last1</CODE> - One past the end of the first range.<DD><CODE>first2</CODE> - Beginning of the second range.<DD><CODE>last2</CODE> - One past the end of the second range.<DD><CODE>comp</CODE> - Comparison function.<DT><B>Returns:</B><DD><code>true</code> if the sequence of elements in the
                  range <code>[first1, last1)</code> is lexicographically
                  less than that in <code>[first1, last1)</code>,
                  otherwise <code>false</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="next_permutation(short[], int, int)"><!-- --></A><H3>
next_permutation</H3>
<PRE>
public static boolean <B>next_permutation</B>(short[]&nbsp;array,
                                       int&nbsp;first,
                                       int&nbsp;last)</PRE>
<DL>
<DD>Transforms a range of elements into the next permutation of those
 elements, where the <em>next</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.
 If no such permutation exists, transforms the range into the 
 smallest permutation.
 Ordering of individual elements is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>Returns:</B><DD><code>true</code> if a next permutation exists,
                 <code>false</code> if the range is already the largest
                 permutation.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lexicographical_compare(short[], short[], int, int, int, int)"><CODE>lexicographical_compare(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#prev_permutation(short[], int, int)"><CODE>prev_permutation(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="next_permutation(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
next_permutation</H3>
<PRE>
public static boolean <B>next_permutation</B>(short[]&nbsp;array,
                                       int&nbsp;first,
                                       int&nbsp;last,
                                       <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Transforms a range of elements into the next permutation of those
 elements, where the <em>next</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.
 If no such permutation exists, transforms the range into the 
 smallest permutation.
 Ordering of individual elements is by a user-supplied comparison
 function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function<DT><B>Returns:</B><DD><code>true</code> if a next permutation exists,
                 <code>false</code> if the range is already the largest
                 permutation.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lexicographical_compare(short[], short[], int, int, int, int)"><CODE>lexicographical_compare(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#prev_permutation(short[], int, int)"><CODE>prev_permutation(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="prev_permutation(short[], int, int)"><!-- --></A><H3>
prev_permutation</H3>
<PRE>
public static boolean <B>prev_permutation</B>(short[]&nbsp;array,
                                       int&nbsp;first,
                                       int&nbsp;last)</PRE>
<DL>
<DD>Transforms a range of elements into the previous permutation of those
 elements, where the <em>previous</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.
 If no such permutation exists, transforms the range into the 
 largest permutation.
 Ordering of individual elements is by arithmetic comparison.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DT><B>Returns:</B><DD><code>true</code> if a previous permutation exists,
                 <code>false</code> if the range is already the smallest
                 permutation.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lexicographical_compare(short[], short[], int, int, int, int)"><CODE>lexicographical_compare(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#next_permutation(short[], int, int)"><CODE>next_permutation(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="prev_permutation(short[], int, int, jal.SHORT.BinaryPredicate)"><!-- --></A><H3>
prev_permutation</H3>
<PRE>
public static boolean <B>prev_permutation</B>(short[]&nbsp;array,
                                       int&nbsp;first,
                                       int&nbsp;last,
                                       <A HREF="../../jal/SHORT/BinaryPredicate.html">BinaryPredicate</A>&nbsp;comp)</PRE>
<DL>
<DD>Transforms a range of elements into the previous permutation of those
 elements, where the <em>previous</em> permutation is defined by 
 a lexicographical ordering of the set of all permutations.
 If no such permutation exists, transforms the range into the 
 largest permutation.
 Ordering of individual elements is by a user-supplied comparison
 function.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>array</CODE> - Array containing the range.<DD><CODE>first</CODE> - Beginning of the range.<DD><CODE>last</CODE> - One past the end of the range.<DD><CODE>comp</CODE> - Comparison function<DT><B>Returns:</B><DD><code>true</code> if a previous permutation exists,
                 <code>false</code> if the range is already the smallest
                 permutation.<DT><B>See Also: </B><DD><A HREF="../../jal/SHORT/Sorting.html#lexicographical_compare(short[], short[], int, int, int, int)"><CODE>lexicographical_compare(short[], short[], int, int, int, int)</CODE></A>, 
<A HREF="../../jal/SHORT/Sorting.html#next_permutation(short[], int, int)"><CODE>next_permutation(short[], int, int)</CODE></A></DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Sorting.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
<b>Colt 1.0.3</b></EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../jal/SHORT/Range.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;NEXT CLASS</FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Sorting.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<font size="-1"><a href="mailto:wolfgang.hoschek@cern.ch">Submit a bug or feature</a>. Check the <a href="http://cern.ch/hoschek/colt">Colt home page</a> for the latest news.</font>
</BODY>
</HTML>
